{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { useWatch } from 'react-hook-form';\nimport { useGetList } from '../../dataProvider';\nimport { useReference } from '../useReference';\nimport { useReferenceParams } from './useReferenceParams';\n\nvar defaultReferenceSource = function defaultReferenceSource(resource, source) {\n  return \"\".concat(resource, \"@\").concat(source);\n};\n/**\n * A hook for choosing a reference record. Useful for foreign keys.\n *\n * This hook fetches the possible values in the reference resource\n * (using `dataProvider.getList()`), it returns the possible choices\n * as the `choices` attribute.\n *\n * @example\n * const {\n *      choices, // the available reference resource\n * } = useReferenceInputController({\n *      input, // the input props\n *      resource: 'comments',\n *      reference: 'posts',\n *      source: 'post_id',\n * });\n *\n * The hook also allow to filter results. It returns a `setFilters`\n * function. It uses the value to create a filter for the query.\n * You can also add a permanentFilter to further filter the result:\n *\n * @example\n * const {\n *      choices, // the available reference resource\n *      setFilter,\n * } = useReferenceInputController({\n *      input, // the input props\n *      resource: 'comments',\n *      reference: 'posts',\n *      source: 'post_id',\n *      permanentFilter: {\n *          author: 'john'\n *      },\n * });\n */\n\n\nexport var useReferenceInputController = function useReferenceInputController(props) {\n  var debounce = props.debounce,\n      enableGetChoices = props.enableGetChoices,\n      filter = props.filter,\n      _a = props.page,\n      initialPage = _a === void 0 ? 1 : _a,\n      _b = props.perPage,\n      initialPerPage = _b === void 0 ? 25 : _b,\n      initialSort = props.sort,\n      _c = props.queryOptions,\n      queryOptions = _c === void 0 ? {} : _c,\n      reference = props.reference,\n      source = props.source;\n\n  var meta = queryOptions.meta,\n      otherQueryOptions = __rest(queryOptions, [\"meta\"]);\n\n  var _d = useReferenceParams({\n    resource: reference,\n    page: initialPage,\n    perPage: initialPerPage,\n    sort: initialSort,\n    debounce: debounce,\n    filter: filter\n  }),\n      params = _d[0],\n      paramsModifiers = _d[1]; // selection logic\n\n\n  var currentValue = useWatch({\n    name: source\n  });\n  var isGetMatchingEnabled = enableGetChoices ? enableGetChoices(params.filterValues) : true; // fetch possible values\n\n  var _e = useGetList(reference, {\n    pagination: {\n      page: params.page,\n      perPage: params.perPage\n    },\n    sort: {\n      field: params.sort,\n      order: params.order\n    },\n    filter: __assign(__assign({}, params.filter), filter),\n    meta: meta\n  }, __assign({\n    enabled: isGetMatchingEnabled,\n    keepPreviousData: true\n  }, otherQueryOptions)),\n      _f = _e.data,\n      possibleValuesData = _f === void 0 ? [] : _f,\n      total = _e.total,\n      pageInfo = _e.pageInfo,\n      possibleValuesFetching = _e.isFetching,\n      possibleValuesLoading = _e.isLoading,\n      possibleValuesError = _e.error,\n      refetchGetList = _e.refetch; // fetch current value\n\n\n  var _g = useReference({\n    id: currentValue,\n    reference: reference,\n    options: {\n      enabled: currentValue != null && currentValue !== '',\n      meta: meta\n    }\n  }),\n      currentReferenceRecord = _g.referenceRecord,\n      refetchReference = _g.refetch,\n      referenceError = _g.error,\n      referenceLoading = _g.isLoading,\n      referenceFetching = _g.isFetching; // We need to delay the update of the referenceRecord and the finalData\n  // to the next React state update, because otherwise it can raise a warning\n  // with AutocompleteInput saying the current value is not in the list of choices\n\n\n  var _h = useState(null),\n      referenceRecord = _h[0],\n      setReferenceRecord = _h[1];\n\n  useEffect(function () {\n    setReferenceRecord(currentReferenceRecord);\n  }, [currentReferenceRecord]); // add current value to possible sources\n\n  var finalData, finalTotal;\n\n  if (!referenceRecord || possibleValuesData.find(function (record) {\n    return record.id === referenceRecord.id;\n  })) {\n    finalData = possibleValuesData;\n    finalTotal = total;\n  } else {\n    finalData = __spreadArray([referenceRecord], possibleValuesData, true);\n    finalTotal = total == null ? undefined : total + 1;\n  }\n\n  var refetch = useCallback(function () {\n    refetchGetList();\n    refetchReference();\n  }, [refetchGetList, refetchReference]);\n  var currentSort = useMemo(function () {\n    return {\n      field: params.sort,\n      order: params.order\n    };\n  }, [params.sort, params.order]);\n  return {\n    sort: currentSort,\n    allChoices: finalData,\n    availableChoices: possibleValuesData,\n    selectedChoices: [referenceRecord],\n    displayedFilters: params.displayedFilters,\n    error: referenceError || possibleValuesError,\n    filter: params.filter,\n    filterValues: params.filterValues,\n    hideFilter: paramsModifiers.hideFilter,\n    isFetching: referenceFetching || possibleValuesFetching,\n    isLoading: referenceLoading || possibleValuesLoading,\n    page: params.page,\n    perPage: params.perPage,\n    refetch: refetch,\n    resource: reference,\n    setFilters: paramsModifiers.setFilters,\n    setPage: paramsModifiers.setPage,\n    setPerPage: paramsModifiers.setPerPage,\n    setSort: paramsModifiers.setSort,\n    showFilter: paramsModifiers.showFilter,\n    source: source,\n    total: finalTotal,\n    hasNextPage: pageInfo ? pageInfo.hasNextPage : total != null ? params.page * params.perPage < total : undefined,\n    hasPreviousPage: pageInfo ? pageInfo.hasPreviousPage : params.page > 1,\n    isFromReference: true\n  };\n};","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useMemo","useState","useWatch","useGetList","useReference","useReferenceParams","defaultReferenceSource","resource","source","concat","useReferenceInputController","props","enableGetChoices","filter","_a","initialPage","_b","initialPerPage","initialSort","_c","queryOptions","reference","otherQueryOptions","page","perPage","sort","debounce","params","paramsModifiers","currentValue","name","isGetMatchingEnabled","filterValues","pagination","field","order","meta","__assign","enabled","keepPreviousData","_f","possibleValuesData","total","pageInfo","possibleValuesFetching","possibleValuesLoading","possibleValuesError","refetchGetList","id","options","currentReferenceRecord","refetchReference","referenceError","referenceLoading","referenceFetching","referenceRecord","setReferenceRecord","finalData","finalTotal","find","undefined","refetch","currentSort","allChoices","availableChoices","selectedChoices","displayedFilters","error","hideFilter","isFetching","isLoading","setFilters","setPage","setPerPage","setSort","showFilter","hasNextPage","hasPreviousPage","isFromReference"],"sources":["/var/www/a1boots/node_modules/ra-core/src/controller/input/useReferenceInputController.ts"],"sourcesContent":["import { useCallback, useEffect, useMemo, useState } from 'react';\nimport { useWatch } from 'react-hook-form';\nimport { useGetList } from '../../dataProvider';\nimport { FilterPayload, RaRecord, SortPayload } from '../../types';\nimport { useReference } from '../useReference';\nimport { ChoicesContextValue } from '../../form';\nimport { useReferenceParams } from './useReferenceParams';\nimport { UseQueryOptions } from 'react-query';\n\nconst defaultReferenceSource = (resource: string, source: string) =>\n    `${resource}@${source}`;\n\n/**\n * A hook for choosing a reference record. Useful for foreign keys.\n *\n * This hook fetches the possible values in the reference resource\n * (using `dataProvider.getList()`), it returns the possible choices\n * as the `choices` attribute.\n *\n * @example\n * const {\n *      choices, // the available reference resource\n * } = useReferenceInputController({\n *      input, // the input props\n *      resource: 'comments',\n *      reference: 'posts',\n *      source: 'post_id',\n * });\n *\n * The hook also allow to filter results. It returns a `setFilters`\n * function. It uses the value to create a filter for the query.\n * You can also add a permanentFilter to further filter the result:\n *\n * @example\n * const {\n *      choices, // the available reference resource\n *      setFilter,\n * } = useReferenceInputController({\n *      input, // the input props\n *      resource: 'comments',\n *      reference: 'posts',\n *      source: 'post_id',\n *      permanentFilter: {\n *          author: 'john'\n *      },\n * });\n */\nexport const useReferenceInputController = <RecordType extends RaRecord = any>(\n    props: UseReferenceInputControllerParams\n): ChoicesContextValue<RecordType> => {\n    const {\n        debounce,\n        enableGetChoices,\n        filter,\n        page: initialPage = 1,\n        perPage: initialPerPage = 25,\n        sort: initialSort,\n        queryOptions = {},\n        reference,\n        source,\n    } = props;\n    const { meta, ...otherQueryOptions } = queryOptions;\n\n    const [params, paramsModifiers] = useReferenceParams({\n        resource: reference,\n        page: initialPage,\n        perPage: initialPerPage,\n        sort: initialSort,\n        debounce,\n        filter,\n    });\n\n    // selection logic\n    const currentValue = useWatch({ name: source });\n\n    const isGetMatchingEnabled = enableGetChoices\n        ? enableGetChoices(params.filterValues)\n        : true;\n\n    // fetch possible values\n    const {\n        data: possibleValuesData = [],\n        total,\n        pageInfo,\n        isFetching: possibleValuesFetching,\n        isLoading: possibleValuesLoading,\n        error: possibleValuesError,\n        refetch: refetchGetList,\n    } = useGetList<RecordType>(\n        reference,\n        {\n            pagination: {\n                page: params.page,\n                perPage: params.perPage,\n            },\n            sort: { field: params.sort, order: params.order },\n            filter: { ...params.filter, ...filter },\n            meta,\n        },\n        {\n            enabled: isGetMatchingEnabled,\n            keepPreviousData: true,\n            ...otherQueryOptions,\n        }\n    );\n\n    // fetch current value\n    const {\n        referenceRecord: currentReferenceRecord,\n        refetch: refetchReference,\n        error: referenceError,\n        isLoading: referenceLoading,\n        isFetching: referenceFetching,\n    } = useReference<RecordType>({\n        id: currentValue,\n        reference,\n        options: {\n            enabled: currentValue != null && currentValue !== '',\n            meta,\n        },\n    });\n\n    // We need to delay the update of the referenceRecord and the finalData\n    // to the next React state update, because otherwise it can raise a warning\n    // with AutocompleteInput saying the current value is not in the list of choices\n    const [referenceRecord, setReferenceRecord] = useState(null);\n    useEffect(() => {\n        setReferenceRecord(currentReferenceRecord);\n    }, [currentReferenceRecord]);\n\n    // add current value to possible sources\n    let finalData: RecordType[], finalTotal: number;\n    if (\n        !referenceRecord ||\n        possibleValuesData.find(record => record.id === referenceRecord.id)\n    ) {\n        finalData = possibleValuesData;\n        finalTotal = total;\n    } else {\n        finalData = [referenceRecord, ...possibleValuesData];\n        finalTotal = total == null ? undefined : total + 1;\n    }\n\n    const refetch = useCallback(() => {\n        refetchGetList();\n        refetchReference();\n    }, [refetchGetList, refetchReference]);\n\n    const currentSort = useMemo(\n        () => ({\n            field: params.sort,\n            order: params.order,\n        }),\n        [params.sort, params.order]\n    );\n    return {\n        sort: currentSort,\n        allChoices: finalData,\n        availableChoices: possibleValuesData,\n        selectedChoices: [referenceRecord],\n        displayedFilters: params.displayedFilters,\n        error: referenceError || possibleValuesError,\n        filter: params.filter,\n        filterValues: params.filterValues,\n        hideFilter: paramsModifiers.hideFilter,\n        isFetching: referenceFetching || possibleValuesFetching,\n        isLoading: referenceLoading || possibleValuesLoading,\n        page: params.page,\n        perPage: params.perPage,\n        refetch,\n        resource: reference,\n        setFilters: paramsModifiers.setFilters,\n        setPage: paramsModifiers.setPage,\n        setPerPage: paramsModifiers.setPerPage,\n        setSort: paramsModifiers.setSort,\n        showFilter: paramsModifiers.showFilter,\n        source,\n        total: finalTotal,\n        hasNextPage: pageInfo\n            ? pageInfo.hasNextPage\n            : total != null\n            ? params.page * params.perPage < total\n            : undefined,\n        hasPreviousPage: pageInfo ? pageInfo.hasPreviousPage : params.page > 1,\n        isFromReference: true,\n    };\n};\n\nexport interface UseReferenceInputControllerParams<\n    RecordType extends RaRecord = any\n> {\n    debounce?: number;\n    filter?: FilterPayload;\n    queryOptions?: UseQueryOptions<{\n        data: RecordType[];\n        total?: number;\n        pageInfo?: {\n            hasNextPage?: boolean;\n            hasPreviousPage?: boolean;\n        };\n    }> & { meta?: any };\n    page?: number;\n    perPage?: number;\n    record?: RaRecord;\n    reference: string;\n    // @deprecated ignored\n    referenceSource?: typeof defaultReferenceSource;\n    resource?: string;\n    sort?: SortPayload;\n    source: string;\n    enableGetChoices?: (filters: any) => boolean;\n}\n"]},"metadata":{},"sourceType":"module"}