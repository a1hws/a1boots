{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { useQuery, useQueryClient, hashQueryKey } from 'react-query';\nimport { useDataProvider } from './useDataProvider';\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, refetch }\n * - success: { data: [data from store], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ post }) => {\n *     const { data, isLoading, error } = useGetMany(\n *         'tags',\n *         { ids: post.tags },\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(tag =>\n *         <li key={tag.id}>{tag.name}</li>\n *     )}</ul>;\n * };\n */\n\nexport var useGetMany = function (resource, params, options) {\n  if (params === void 0) {\n    params = {};\n  }\n\n  var ids = params.ids,\n      meta = params.meta;\n  var dataProvider = useDataProvider();\n  var queryClient = useQueryClient();\n  var queryCache = queryClient.getQueryCache();\n  return useQuery([resource, 'getMany', {\n    ids: !ids || ids.length === 0 ? [] : ids.map(function (id) {\n      return String(id);\n    }),\n    meta: meta\n  }], function () {\n    if (!ids || ids.length === 0) {\n      // no need to call the dataProvider\n      return Promise.resolve([]);\n    }\n\n    return dataProvider.getMany(resource, {\n      ids: ids,\n      meta: meta\n    }).then(function (_a) {\n      var data = _a.data;\n      return data;\n    });\n  }, __assign({\n    placeholderData: function () {\n      var records = !ids || ids.length === 0 ? [] : ids.map(function (id) {\n        var _a, _b;\n\n        var queryHash = hashQueryKey([resource, 'getOne', {\n          id: String(id),\n          meta: meta\n        }]);\n        return (_b = (_a = queryCache.get(queryHash)) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.data;\n      });\n\n      if (records.some(function (record) {\n        return record === undefined;\n      })) {\n        return undefined;\n      } else {\n        return records;\n      }\n    },\n    onSuccess: function (data) {\n      // optimistically populate the getOne cache\n      data.forEach(function (record) {\n        queryClient.setQueryData([resource, 'getOne', {\n          id: String(record.id),\n          meta: meta\n        }], function (oldRecord) {\n          return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;\n        });\n      });\n    },\n    retry: false\n  }, options));\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;AAAA,SACIA,QADJ,EAIIC,cAJJ,EAKIC,YALJ,QAMO,aANP;AASA,SAASC,eAAT,QAAgC,mBAAhC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCA,OAAO,IAAMC,UAAU,GAAG,UACtBC,QADsB,EAEtBC,MAFsB,EAGtBC,OAHsB,EAGwB;EAD9C;IAAAD;EAAmC;;EAG3B,OAAG,GAAWA,MAAM,IAApB;EAAA,IAAKE,IAAI,GAAKF,MAAM,KAApB;EACR,IAAMG,YAAY,GAAGN,eAAe,EAApC;EACA,IAAMO,WAAW,GAAGT,cAAc,EAAlC;EACA,IAAMU,UAAU,GAAGD,WAAW,CAACE,aAAZ,EAAnB;EAEA,OAAOZ,QAAQ,CACX,CACIK,QADJ,EAEI,SAFJ,EAGI;IACIQ,GAAG,EAAE,CAACA,GAAD,IAAQA,GAAG,CAACC,MAAJ,KAAe,CAAvB,GAA2B,EAA3B,GAAgCD,GAAG,CAACE,GAAJ,CAAQ,cAAE;MAAI,aAAM,CAACC,EAAD,CAAN;IAAU,CAAxB,CADzC;IAEIR,IAAI;EAFR,CAHJ,CADW,EASX;IACI,IAAI,CAACK,GAAD,IAAQA,GAAG,CAACC,MAAJ,KAAe,CAA3B,EAA8B;MAC1B;MACA,OAAOG,OAAO,CAACC,OAAR,CAAgB,EAAhB,CAAP;IACH;;IACD,OAAOT,YAAY,CACdU,OADE,CACkBd,QADlB,EAC4B;MAAEQ,GAAG,KAAL;MAAOL,IAAI;IAAX,CAD5B,EAEFY,IAFE,CAEG,UAACC,EAAD,EAAS;UAANC,IAAI;MAAO;IAAI,CAFrB,CAAP;EAGH,CAjBU,EAiBVC;IAEGC,eAAe,EAAE;MACb,IAAMC,OAAO,GACT,CAACZ,GAAD,IAAQA,GAAG,CAACC,MAAJ,KAAe,CAAvB,GACM,EADN,GAEMD,GAAG,CAACE,GAAJ,CAAQ,cAAE;;;QACN,IAAMW,SAAS,GAAGxB,YAAY,CAAC,CAC3BG,QAD2B,EAE3B,QAF2B,EAG3B;UAAEW,EAAE,EAAEW,MAAM,CAACX,EAAD,CAAZ;UAAkBR,IAAI;QAAtB,CAH2B,CAAD,CAA9B;QAKA,OAAO,sBAAU,CAACoB,GAAX,CAA2BF,SAA3B,OAAqC,IAArC,IAAqCL,aAArC,GAAqC,MAArC,GAAqCA,GACtCQ,KADC,MACI,IADJ,IACIC,aADJ,GACI,MADJ,GACIA,GAAER,IADb;MAEH,CARD,CAHV;;MAYA,IAAIG,OAAO,CAACM,IAAR,CAAa,kBAAM;QAAI,aAAM,KAAKC,SAAX;MAAoB,CAA3C,CAAJ,EAAkD;QAC9C,OAAOA,SAAP;MACH,CAFD,MAEO;QACH,OAAOP,OAAP;MACH;IACJ,CApBJ;IAqBGQ,SAAS,EAAE,gBAAI;MACX;MACAX,IAAI,CAACY,OAAL,CAAa,kBAAM;QACfxB,WAAW,CAACyB,YAAZ,CACI,CAAC9B,QAAD,EAAW,QAAX,EAAqB;UAAEW,EAAE,EAAEW,MAAM,CAACS,MAAM,CAACpB,EAAR,CAAZ;UAAyBR,IAAI;QAA7B,CAArB,CADJ,EAEI,qBAAS;UAAI,gBAAS,SAAT,aAAS,WAAT,eAAa4B,MAAb;QAAmB,CAFpC;MAIH,CALD;IAMH,CA7BJ;IA8BGC,KAAK,EAAE;EA9BV,GA+BM9B,OA/BN,CAjBU,CAAf;AAmDH,CA7DM","names":["useQuery","useQueryClient","hashQueryKey","useDataProvider","useGetMany","resource","params","options","meta","dataProvider","queryClient","queryCache","getQueryCache","ids","length","map","id","Promise","resolve","getMany","then","_a","data","__assign","placeholderData","records","queryHash","String","get","state","_b","some","undefined","onSuccess","forEach","setQueryData","record","retry"],"sources":["/var/www/a1boots/node_modules/ra-core/src/dataProvider/useGetMany.ts"],"sourcesContent":["import {\n    useQuery,\n    UseQueryOptions,\n    UseQueryResult,\n    useQueryClient,\n    hashQueryKey,\n} from 'react-query';\n\nimport { RaRecord, GetManyParams } from '../types';\nimport { useDataProvider } from './useDataProvider';\n\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, refetch }\n * - success: { data: [data from store], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ post }) => {\n *     const { data, isLoading, error } = useGetMany(\n *         'tags',\n *         { ids: post.tags },\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(tag =>\n *         <li key={tag.id}>{tag.name}</li>\n *     )}</ul>;\n * };\n */\nexport const useGetMany = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: Partial<GetManyParams> = {},\n    options?: UseQueryOptions<RecordType[], Error>\n): UseGetManyHookValue<RecordType> => {\n    const { ids, meta } = params;\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const queryCache = queryClient.getQueryCache();\n\n    return useQuery<RecordType[], Error, RecordType[]>(\n        [\n            resource,\n            'getMany',\n            {\n                ids: !ids || ids.length === 0 ? [] : ids.map(id => String(id)),\n                meta,\n            },\n        ],\n        () => {\n            if (!ids || ids.length === 0) {\n                // no need to call the dataProvider\n                return Promise.resolve([]);\n            }\n            return dataProvider\n                .getMany<RecordType>(resource, { ids, meta })\n                .then(({ data }) => data);\n        },\n        {\n            placeholderData: () => {\n                const records =\n                    !ids || ids.length === 0\n                        ? []\n                        : ids.map(id => {\n                              const queryHash = hashQueryKey([\n                                  resource,\n                                  'getOne',\n                                  { id: String(id), meta },\n                              ]);\n                              return queryCache.get<RecordType>(queryHash)\n                                  ?.state?.data;\n                          });\n                if (records.some(record => record === undefined)) {\n                    return undefined;\n                } else {\n                    return records as RecordType[];\n                }\n            },\n            onSuccess: data => {\n                // optimistically populate the getOne cache\n                data.forEach(record => {\n                    queryClient.setQueryData(\n                        [resource, 'getOne', { id: String(record.id), meta }],\n                        oldRecord => oldRecord ?? record\n                    );\n                });\n            },\n            retry: false,\n            ...options,\n        }\n    );\n};\n\nexport type UseGetManyHookValue<\n    RecordType extends RaRecord = any\n> = UseQueryResult<RecordType[], Error>;\n"]},"metadata":{},"sourceType":"module"}