{"ast":null,"code":"import { useCallback, useEffect, useRef } from 'react';\nimport { useLocation, useNavigate } from 'react-router-dom';\nimport { useQueryClient } from 'react-query';\nimport useAuthProvider, { defaultAuthParams } from './useAuthProvider';\nimport { useResetStore } from '../store';\nimport { useBasename } from '../routing';\nimport { removeDoubleSlashes } from '../routing/useCreatePath';\n/**\n * Get a callback for calling the authProvider.logout() method,\n * redirect to the login page, and clear the store.\n *\n * @see useAuthProvider\n *\n * @returns {Function} logout callback\n *\n * @example\n *\n * import { useLogout } from 'react-admin';\n *\n * const LogoutButton = () => {\n *     const logout = useLogout();\n *     const handleClick = () => logout();\n *     return <button onClick={handleClick}>Logout</button>;\n * }\n */\n\nvar useLogout = function () {\n  var authProvider = useAuthProvider();\n  var queryClient = useQueryClient();\n  var resetStore = useResetStore();\n  var navigate = useNavigate(); // useNavigate forces rerenders on every navigation, even if we don't use the result\n  // see https://github.com/remix-run/react-router/issues/7634\n  // so we use a ref to bail out of rerenders when we don't need to\n\n  var navigateRef = useRef(navigate);\n  var location = useLocation();\n  var locationRef = useRef(location);\n  var basename = useBasename();\n  var loginUrl = removeDoubleSlashes(\"\".concat(basename, \"/\").concat(defaultAuthParams.loginUrl));\n  /*\n   * We need the current location to pass in the router state\n   * so that the login hook knows where to redirect to as next route after login.\n   *\n   * But if we used the location from useLocation as a dependency of the logout\n   * function, it would be rebuilt each time the user changes location.\n   * Consequently, that would force a rerender of all components using this hook\n   * upon navigation (CoreAdminRouter for example).\n   *\n   * To avoid that, we store the location in a ref.\n   */\n\n  useEffect(function () {\n    locationRef.current = location;\n    navigateRef.current = navigate;\n  }, [location, navigate]);\n  var logout = useCallback(function (params, redirectTo, redirectToCurrentLocationAfterLogin) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    if (redirectTo === void 0) {\n      redirectTo = loginUrl;\n    }\n\n    if (redirectToCurrentLocationAfterLogin === void 0) {\n      redirectToCurrentLocationAfterLogin = true;\n    }\n\n    return authProvider.logout(params).then(function (redirectToFromProvider) {\n      if (redirectToFromProvider === false || redirectTo === false) {\n        resetStore();\n        queryClient.clear(); // do not redirect\n\n        return;\n      }\n\n      var finalRedirectTo = redirectToFromProvider || redirectTo;\n\n      if (finalRedirectTo === null || finalRedirectTo === void 0 ? void 0 : finalRedirectTo.startsWith('http')) {\n        // absolute link (e.g. https://my.oidc.server/login)\n        resetStore();\n        queryClient.clear();\n        window.location.href = finalRedirectTo;\n        return finalRedirectTo;\n      } // redirectTo is an internal location that may contain a query string, e.g. '/login?foo=bar'\n      // we must split it to pass a structured location to navigate()\n\n\n      var redirectToParts = finalRedirectTo.split('?');\n      var newLocation = {\n        pathname: redirectToParts[0]\n      };\n      var newLocationOptions = {};\n\n      if (redirectToCurrentLocationAfterLogin && locationRef.current && locationRef.current.pathname) {\n        newLocationOptions = {\n          state: {\n            nextPathname: locationRef.current.pathname,\n            nextSearch: locationRef.current.search\n          }\n        };\n      }\n\n      if (redirectToParts[1]) {\n        newLocation.search = redirectToParts[1];\n      }\n\n      navigateRef.current(newLocation, newLocationOptions);\n      resetStore();\n      queryClient.clear();\n      return redirectToFromProvider;\n    });\n  }, [authProvider, resetStore, loginUrl, queryClient]);\n  var logoutWithoutProvider = useCallback(function (_) {\n    navigate({\n      pathname: loginUrl\n    }, {\n      state: {\n        nextPathname: location && location.pathname\n      }\n    });\n    resetStore();\n    queryClient.clear();\n    return Promise.resolve();\n  }, [resetStore, location, navigate, loginUrl, queryClient]);\n  return authProvider ? logout : logoutWithoutProvider;\n};\n\nexport default useLogout;","map":{"version":3,"mappings":"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","names":["useCallback","useEffect","useRef","useLocation","useNavigate","useQueryClient","useAuthProvider","defaultAuthParams","useResetStore","useBasename","removeDoubleSlashes","useLogout","authProvider","queryClient","resetStore","navigate","navigateRef","location","locationRef","basename","loginUrl","concat","current","logout","params","redirectTo","redirectToCurrentLocationAfterLogin","then","redirectToFromProvider","clear","finalRedirectTo","startsWith","window","href","redirectToParts","split","newLocation","pathname","newLocationOptions","state","nextPathname","nextSearch","search","logoutWithoutProvider","Promise","resolve"],"sources":["/var/www/a1boots/node_modules/ra-core/src/auth/useLogout.ts"],"sourcesContent":["import { useCallback, useEffect, useRef } from 'react';\nimport { useLocation, useNavigate, Path } from 'react-router-dom';\nimport { useQueryClient } from 'react-query';\n\nimport useAuthProvider, { defaultAuthParams } from './useAuthProvider';\nimport { useResetStore } from '../store';\nimport { useBasename } from '../routing';\nimport { removeDoubleSlashes } from '../routing/useCreatePath';\n\n/**\n * Get a callback for calling the authProvider.logout() method,\n * redirect to the login page, and clear the store.\n *\n * @see useAuthProvider\n *\n * @returns {Function} logout callback\n *\n * @example\n *\n * import { useLogout } from 'react-admin';\n *\n * const LogoutButton = () => {\n *     const logout = useLogout();\n *     const handleClick = () => logout();\n *     return <button onClick={handleClick}>Logout</button>;\n * }\n */\nconst useLogout = (): Logout => {\n    const authProvider = useAuthProvider();\n    const queryClient = useQueryClient();\n    const resetStore = useResetStore();\n    const navigate = useNavigate();\n    // useNavigate forces rerenders on every navigation, even if we don't use the result\n    // see https://github.com/remix-run/react-router/issues/7634\n    // so we use a ref to bail out of rerenders when we don't need to\n    const navigateRef = useRef(navigate);\n    const location = useLocation();\n    const locationRef = useRef(location);\n    const basename = useBasename();\n    const loginUrl = removeDoubleSlashes(\n        `${basename}/${defaultAuthParams.loginUrl}`\n    );\n\n    /*\n     * We need the current location to pass in the router state\n     * so that the login hook knows where to redirect to as next route after login.\n     *\n     * But if we used the location from useLocation as a dependency of the logout\n     * function, it would be rebuilt each time the user changes location.\n     * Consequently, that would force a rerender of all components using this hook\n     * upon navigation (CoreAdminRouter for example).\n     *\n     * To avoid that, we store the location in a ref.\n     */\n    useEffect(() => {\n        locationRef.current = location;\n        navigateRef.current = navigate;\n    }, [location, navigate]);\n\n    const logout: Logout = useCallback(\n        (\n            params = {},\n            redirectTo = loginUrl,\n            redirectToCurrentLocationAfterLogin = true\n        ) =>\n            authProvider.logout(params).then(redirectToFromProvider => {\n                if (redirectToFromProvider === false || redirectTo === false) {\n                    resetStore();\n                    queryClient.clear();\n                    // do not redirect\n                    return;\n                }\n\n                const finalRedirectTo = redirectToFromProvider || redirectTo;\n\n                if (finalRedirectTo?.startsWith('http')) {\n                    // absolute link (e.g. https://my.oidc.server/login)\n                    resetStore();\n                    queryClient.clear();\n                    window.location.href = finalRedirectTo;\n                    return finalRedirectTo;\n                }\n\n                // redirectTo is an internal location that may contain a query string, e.g. '/login?foo=bar'\n                // we must split it to pass a structured location to navigate()\n                const redirectToParts = finalRedirectTo.split('?');\n                const newLocation: Partial<Path> = {\n                    pathname: redirectToParts[0],\n                };\n                let newLocationOptions = {};\n\n                if (\n                    redirectToCurrentLocationAfterLogin &&\n                    locationRef.current &&\n                    locationRef.current.pathname\n                ) {\n                    newLocationOptions = {\n                        state: {\n                            nextPathname: locationRef.current.pathname,\n                            nextSearch: locationRef.current.search,\n                        },\n                    };\n                }\n                if (redirectToParts[1]) {\n                    newLocation.search = redirectToParts[1];\n                }\n                navigateRef.current(newLocation, newLocationOptions);\n                resetStore();\n                queryClient.clear();\n\n                return redirectToFromProvider;\n            }),\n        [authProvider, resetStore, loginUrl, queryClient]\n    );\n\n    const logoutWithoutProvider = useCallback(\n        _ => {\n            navigate(\n                {\n                    pathname: loginUrl,\n                },\n                {\n                    state: {\n                        nextPathname: location && location.pathname,\n                    },\n                }\n            );\n            resetStore();\n            queryClient.clear();\n            return Promise.resolve();\n        },\n        [resetStore, location, navigate, loginUrl, queryClient]\n    );\n\n    return authProvider ? logout : logoutWithoutProvider;\n};\n\n/**\n * Log the current user out by calling the authProvider.logout() method,\n * and redirect them to the login screen.\n *\n * @param {Object} params The parameters to pass to the authProvider\n * @param {string} redirectTo The path name to redirect the user to (optional, defaults to login)\n * @param {boolean} redirectToCurrentLocationAfterLogin Whether the button shall record the current location to redirect to it after login. true by default.\n *\n * @return {Promise} The authProvider response\n */\ntype Logout = (\n    params?: any,\n    redirectTo?: string | false,\n    redirectToCurrentLocationAfterLogin?: boolean\n) => Promise<any>;\n\nexport default useLogout;\n"]},"metadata":{},"sourceType":"module"}