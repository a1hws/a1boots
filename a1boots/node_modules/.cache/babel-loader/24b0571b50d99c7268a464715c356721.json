{"ast":null,"code":"import inflection from 'inflection';\n/**\n * Returns an array of arguments to use with the translate function for the label of a field.\n * The label will be the one specified by the label prop or one computed from the resource and source props.\n *\n * Usage:\n *  <span>\n *      {translate(...getFieldLabelTranslationArgs({ label, resource, source }))}\n *  </span>\n *\n * @see useTranslateLabel for a ready-to-use hook\n */\n\nexport default (function (options) {\n  if (!options) return [''];\n  var label = options.label,\n      prefix = options.prefix,\n      resource = options.resource,\n      resourceFromContext = options.resourceFromContext,\n      source = options.source;\n  if (typeof label !== 'undefined') return [label, {\n    _: label\n  }];\n  if (typeof source === 'undefined') return [''];\n\n  var _a = getSourceParts(source),\n      sourceWithoutDigits = _a.sourceWithoutDigits,\n      sourceSuffix = _a.sourceSuffix;\n\n  var defaultLabel = inflection.transform(sourceSuffix.replace(/\\./g, ' '), ['underscore', 'humanize']);\n\n  if (resource) {\n    return [\"resources.\".concat(resource, \".fields.\").concat(sourceWithoutDigits), {\n      _: defaultLabel\n    }];\n  }\n\n  if (prefix) {\n    return [\"\".concat(prefix, \".\").concat(sourceWithoutDigits), {\n      _: defaultLabel\n    }];\n  }\n\n  return [\"resources.\".concat(resourceFromContext, \".fields.\").concat(sourceWithoutDigits), {\n    _: defaultLabel\n  }];\n});\n/**\n * Uses the source string to guess a translation message and a default label.\n *\n * @example\n * getSourceParts('pictures') // { sourceWithoutDigits: 'pictures', sourceSuffix: 'pictures' }\n * getSourceParts('pictures.url') // { sourceWithoutDigits: 'pictures.url', sourceSuffix: 'pictures.url' }\n * getSourceParts('pictures.0.url') // { sourceWithoutDigits: 'pictures.url', sourceSuffix: 'url' }\n * getSourceParts('pictures.12.urls.5.protocol') // { sourceWithoutDigits: 'pictures.urls.protocol', sourceSuffix: 'protocol' }\n */\n\nvar getSourceParts = function (source) {\n  // remove digits, e.g. 'book.authors.2.categories.3.identifier.name' => 'book.authors.categories.identifier.name'\n  var sourceWithoutDigits = source.replace(/\\.\\d+\\./g, '.'); // get final part, e.g. 'book.authors.2.categories.3.identifier.name' => 'identifier.name'\n  // we're not using a regexp here to avoid code sacnning alert \"Polynomial regular expression used on uncontrolled data\"\n\n  var parts = source.split('.');\n  var lastPartWithDigits;\n  parts.forEach(function (part, index) {\n    if (onlyDigits(part)) {\n      lastPartWithDigits = index;\n    }\n  });\n  var sourceSuffix = lastPartWithDigits != null ? parts.slice(lastPartWithDigits + 1).join('.') : source;\n  return {\n    sourceWithoutDigits: sourceWithoutDigits,\n    sourceSuffix: sourceSuffix\n  };\n}; // 48 and 57 are the char codes for \"0\" and \"9\", respectively\n\n\nvar onlyDigits = function (s) {\n  for (var i = s.length - 1; i >= 0; i--) {\n    var d = s.charCodeAt(i);\n    if (d < 48 || d > 57) return false;\n  }\n\n  return true;\n};","map":{"version":3,"mappings":"AAAA,OAAOA,UAAP,MAAuB,YAAvB;AAYA;;;;;;;;;;;;AAWA,gBAAe,UAACC,OAAD,EAAe;EAC1B,IAAI,CAACA,OAAL,EAAc,OAAO,CAAC,EAAD,CAAP;EAEN,SAAK,GAAoDA,OAAO,MAAhE;EAAA,IAAOC,MAAM,GAA4CD,OAAO,OAAhE;EAAA,IAAeE,QAAQ,GAAkCF,OAAO,SAAhE;EAAA,IAAyBG,mBAAmB,GAAaH,OAAO,oBAAhE;EAAA,IAA8CI,MAAM,GAAKJ,OAAO,OAAhE;EAER,IAAI,OAAOK,KAAP,KAAiB,WAArB,EAAkC,OAAO,CAACA,KAAD,EAAQ;IAAEC,CAAC,EAAED;EAAL,CAAR,CAAP;EAElC,IAAI,OAAOD,MAAP,KAAkB,WAAtB,EAAmC,OAAO,CAAC,EAAD,CAAP;;EAE7B,SAAwCG,cAAc,CAACH,MAAD,CAAtD;EAAA,IAAEI,mBAAmB,yBAArB;EAAA,IAAuBC,YAAY,kBAAnC;;EAEN,IAAMC,YAAY,GAAGX,UAAU,CAACY,SAAX,CACjBF,YAAY,CAACG,OAAb,CAAqB,KAArB,EAA4B,GAA5B,CADiB,EAEjB,CAAC,YAAD,EAAe,UAAf,CAFiB,CAArB;;EAKA,IAAIV,QAAJ,EAAc;IACV,OAAO,CACH,oBAAaA,QAAb,EAAqB,UAArB,EAAqBW,MAArB,CAAgCL,mBAAhC,CADG,EAEH;MAAEF,CAAC,EAAEI;IAAL,CAFG,CAAP;EAIH;;EAED,IAAIT,MAAJ,EAAY;IACR,OAAO,CAAC,UAAGA,MAAH,EAAS,GAAT,EAASY,MAAT,CAAaL,mBAAb,CAAD,EAAqC;MAAEF,CAAC,EAAEI;IAAL,CAArC,CAAP;EACH;;EAED,OAAO,CACH,oBAAaP,mBAAb,EAAgC,UAAhC,EAAgCU,MAAhC,CAA2CL,mBAA3C,CADG,EAEH;IAAEF,CAAC,EAAEI;EAAL,CAFG,CAAP;AAIH,CA/BD;AAiCA;;;;;;;;;;AASA,IAAMH,cAAc,GAAG,UAACH,MAAD,EAAe;EAClC;EACA,IAAMI,mBAAmB,GAAGJ,MAAM,CAACQ,OAAP,CAAe,UAAf,EAA2B,GAA3B,CAA5B,CAFkC,CAGlC;EACA;;EACA,IAAME,KAAK,GAAGV,MAAM,CAACW,KAAP,CAAa,GAAb,CAAd;EACA,IAAIC,kBAAJ;EACAF,KAAK,CAACG,OAAN,CAAc,UAACC,IAAD,EAAOC,KAAP,EAAY;IACtB,IAAIC,UAAU,CAACF,IAAD,CAAd,EAAsB;MAClBF,kBAAkB,GAAGG,KAArB;IACH;EACJ,CAJD;EAKA,IAAMV,YAAY,GACdO,kBAAkB,IAAI,IAAtB,GACMF,KAAK,CAACO,KAAN,CAAYL,kBAAkB,GAAG,CAAjC,EAAoCM,IAApC,CAAyC,GAAzC,CADN,GAEMlB,MAHV;EAKA,OAAO;IAAEI,mBAAmB,qBAArB;IAAuBC,YAAY;EAAnC,CAAP;AACH,CAlBD,C,CAoBA;;;AACA,IAAMW,UAAU,GAAG,aAAC;EAChB,KAAK,IAAIG,CAAC,GAAGC,CAAC,CAACC,MAAF,GAAW,CAAxB,EAA2BF,CAAC,IAAI,CAAhC,EAAmCA,CAAC,EAApC,EAAwC;IACpC,IAAMG,CAAC,GAAGF,CAAC,CAACG,UAAF,CAAaJ,CAAb,CAAV;IACA,IAAIG,CAAC,GAAG,EAAJ,IAAUA,CAAC,GAAG,EAAlB,EAAsB,OAAO,KAAP;EACzB;;EACD,OAAO,IAAP;AACH,CAND","names":["inflection","options","prefix","resource","resourceFromContext","source","label","_","getSourceParts","sourceWithoutDigits","sourceSuffix","defaultLabel","transform","replace","concat","parts","split","lastPartWithDigits","forEach","part","index","onlyDigits","slice","join","i","s","length","d","charCodeAt"],"sources":["/var/www/a1boots/node_modules/ra-core/src/util/getFieldLabelTranslationArgs.ts"],"sourcesContent":["import inflection from 'inflection';\n\ninterface Args {\n    label?: string;\n    prefix?: string;\n    resource?: string;\n    resourceFromContext?: string;\n    source?: string;\n}\n\ntype TranslationArguments = [string, any?];\n\n/**\n * Returns an array of arguments to use with the translate function for the label of a field.\n * The label will be the one specified by the label prop or one computed from the resource and source props.\n *\n * Usage:\n *  <span>\n *      {translate(...getFieldLabelTranslationArgs({ label, resource, source }))}\n *  </span>\n *\n * @see useTranslateLabel for a ready-to-use hook\n */\nexport default (options?: Args): TranslationArguments => {\n    if (!options) return [''];\n\n    const { label, prefix, resource, resourceFromContext, source } = options;\n\n    if (typeof label !== 'undefined') return [label, { _: label }];\n\n    if (typeof source === 'undefined') return [''];\n\n    const { sourceWithoutDigits, sourceSuffix } = getSourceParts(source);\n\n    const defaultLabel = inflection.transform(\n        sourceSuffix.replace(/\\./g, ' '),\n        ['underscore', 'humanize']\n    );\n\n    if (resource) {\n        return [\n            `resources.${resource}.fields.${sourceWithoutDigits}`,\n            { _: defaultLabel },\n        ];\n    }\n\n    if (prefix) {\n        return [`${prefix}.${sourceWithoutDigits}`, { _: defaultLabel }];\n    }\n\n    return [\n        `resources.${resourceFromContext}.fields.${sourceWithoutDigits}`,\n        { _: defaultLabel },\n    ];\n};\n\n/**\n * Uses the source string to guess a translation message and a default label.\n *\n * @example\n * getSourceParts('pictures') // { sourceWithoutDigits: 'pictures', sourceSuffix: 'pictures' }\n * getSourceParts('pictures.url') // { sourceWithoutDigits: 'pictures.url', sourceSuffix: 'pictures.url' }\n * getSourceParts('pictures.0.url') // { sourceWithoutDigits: 'pictures.url', sourceSuffix: 'url' }\n * getSourceParts('pictures.12.urls.5.protocol') // { sourceWithoutDigits: 'pictures.urls.protocol', sourceSuffix: 'protocol' }\n */\nconst getSourceParts = (source: string) => {\n    // remove digits, e.g. 'book.authors.2.categories.3.identifier.name' => 'book.authors.categories.identifier.name'\n    const sourceWithoutDigits = source.replace(/\\.\\d+\\./g, '.');\n    // get final part, e.g. 'book.authors.2.categories.3.identifier.name' => 'identifier.name'\n    // we're not using a regexp here to avoid code sacnning alert \"Polynomial regular expression used on uncontrolled data\"\n    const parts = source.split('.');\n    let lastPartWithDigits;\n    parts.forEach((part, index) => {\n        if (onlyDigits(part)) {\n            lastPartWithDigits = index;\n        }\n    });\n    const sourceSuffix =\n        lastPartWithDigits != null\n            ? parts.slice(lastPartWithDigits + 1).join('.')\n            : source;\n\n    return { sourceWithoutDigits, sourceSuffix };\n};\n\n// 48 and 57 are the char codes for \"0\" and \"9\", respectively\nconst onlyDigits = s => {\n    for (let i = s.length - 1; i >= 0; i--) {\n        const d = s.charCodeAt(i);\n        if (d < 48 || d > 57) return false;\n    }\n    return true;\n};\n"]},"metadata":{},"sourceType":"module"}