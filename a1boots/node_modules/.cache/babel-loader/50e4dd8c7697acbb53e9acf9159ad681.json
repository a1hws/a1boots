{"ast":null,"code":"import lodashMemoize from 'lodash/memoize';\n/* eslint-disable no-underscore-dangle */\n\n/* @link http://stackoverflow.com/questions/46155/validate-email-address-in-javascript */\n\nvar EMAIL_REGEX = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; // eslint-disable-line no-useless-escape\n\nvar isEmpty = function (value) {\n  return typeof value === 'undefined' || value === null || value === '' || Array.isArray(value) && value.length === 0;\n}; // type predicate, see https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates\n\n\nfunction isValidationErrorMessageWithArgs(error) {\n  return error ? error.hasOwnProperty('message') : false;\n}\n\nvar getMessage = function (message, messageArgs, value, values) {\n  return typeof message === 'function' ? message({\n    args: messageArgs,\n    value: value,\n    values: values\n  }) : messageArgs ? {\n    message: message,\n    args: messageArgs\n  } : message;\n}; // If we define validation functions directly in JSX, it will\n// result in a new function at every render, and then trigger infinite re-render.\n// Hence, we memoize every built-in validator to prevent a \"Maximum call stack\" error.\n\n\nvar memoize = function (fn) {\n  return lodashMemoize(fn, function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return JSON.stringify(args);\n  });\n};\n\nvar isFunction = function (value) {\n  return typeof value === 'function';\n};\n\nexport var combine2Validators = function (validator1, validator2) {\n  return function (value, values, meta) {\n    var result1 = validator1(value, values, meta);\n\n    if (!result1) {\n      return validator2(value, values, meta);\n    }\n\n    if (typeof result1 === 'string' || isValidationErrorMessageWithArgs(result1)) {\n      return result1;\n    }\n\n    return result1.then(function (resolvedResult1) {\n      if (!resolvedResult1) {\n        return validator2(value, values, meta);\n      }\n\n      return resolvedResult1;\n    });\n  };\n}; // Compose multiple validators into a single one for use with react-hook-form\n\nexport var composeValidators = function () {\n  var validators = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    validators[_i] = arguments[_i];\n  }\n\n  var allValidators = (Array.isArray(validators[0]) ? validators[0] : validators).filter(isFunction);\n  return allValidators.reduce(combine2Validators, function () {\n    return null;\n  });\n}; // Compose multiple validators into a single one for use with react-hook-form\n\nexport var composeSyncValidators = function () {\n  var validators = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    validators[_i] = arguments[_i];\n  }\n\n  return function (value, values, meta) {\n    var allValidators = (Array.isArray(validators[0]) ? validators[0] : validators).filter(isFunction);\n\n    for (var _i = 0, allValidators_1 = allValidators; _i < allValidators_1.length; _i++) {\n      var validator = allValidators_1[_i];\n      var error = validator(value, values, meta);\n\n      if (error) {\n        return error;\n      }\n    }\n  };\n};\n/**\n * Required validator\n *\n * Returns an error if the value is null, undefined, or empty\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const titleValidators = [required('The title is required')];\n * <TextInput name=\"title\" validate={titleValidators} />\n */\n\nexport var required = memoize(function (message) {\n  if (message === void 0) {\n    message = 'ra.validation.required';\n  }\n\n  return Object.assign(function (value, values) {\n    return isEmpty(value) ? getMessage(message, undefined, value, values) : undefined;\n  }, {\n    isRequired: true\n  });\n});\n/**\n * Minimum length validator\n *\n * Returns an error if the value has a length less than the parameter\n *\n * @param {integer} min\n * @param {string|Function} message\n *\n * @example\n *\n * const passwordValidators = [minLength(10, 'Should be at least 10 characters')];\n * <TextInput type=\"password\" name=\"password\" validate={passwordValidators} />\n */\n\nexport var minLength = memoize(function (min, message) {\n  if (message === void 0) {\n    message = 'ra.validation.minLength';\n  }\n\n  return function (value, values) {\n    return !isEmpty(value) && value.length < min ? getMessage(message, {\n      min: min\n    }, value, values) : undefined;\n  };\n});\n/**\n * Maximum length validator\n *\n * Returns an error if the value has a length higher than the parameter\n *\n * @param {integer} max\n * @param {string|Function} message\n *\n * @example\n *\n * const nameValidators = [maxLength(10, 'Should be at most 10 characters')];\n * <TextInput name=\"name\" validate={nameValidators} />\n */\n\nexport var maxLength = memoize(function (max, message) {\n  if (message === void 0) {\n    message = 'ra.validation.maxLength';\n  }\n\n  return function (value, values) {\n    return !isEmpty(value) && value.length > max ? getMessage(message, {\n      max: max\n    }, value, values) : undefined;\n  };\n});\n/**\n * Minimum validator\n *\n * Returns an error if the value is less than the parameter\n *\n * @param {integer} min\n * @param {string|Function} message\n *\n * @example\n *\n * const fooValidators = [minValue(5, 'Should be more than 5')];\n * <NumberInput name=\"foo\" validate={fooValidators} />\n */\n\nexport var minValue = memoize(function (min, message) {\n  if (message === void 0) {\n    message = 'ra.validation.minValue';\n  }\n\n  return function (value, values) {\n    return !isEmpty(value) && value < min ? getMessage(message, {\n      min: min\n    }, value, values) : undefined;\n  };\n});\n/**\n * Maximum validator\n *\n * Returns an error if the value is higher than the parameter\n *\n * @param {integer} max\n * @param {string|Function} message\n *\n * @example\n *\n * const fooValidators = [maxValue(10, 'Should be less than 10')];\n * <NumberInput name=\"foo\" validate={fooValidators} />\n */\n\nexport var maxValue = memoize(function (max, message) {\n  if (message === void 0) {\n    message = 'ra.validation.maxValue';\n  }\n\n  return function (value, values) {\n    return !isEmpty(value) && value > max ? getMessage(message, {\n      max: max\n    }, value, values) : undefined;\n  };\n});\n/**\n * Number validator\n *\n * Returns an error if the value is not a number\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const ageValidators = [number('Must be a number')];\n * <TextInput name=\"age\" validate={ageValidators} />\n */\n\nexport var number = memoize(function (message) {\n  if (message === void 0) {\n    message = 'ra.validation.number';\n  }\n\n  return function (value, values) {\n    return !isEmpty(value) && isNaN(Number(value)) ? getMessage(message, undefined, value, values) : undefined;\n  };\n});\n/**\n * Regular expression validator\n *\n * Returns an error if the value does not match the pattern given as parameter\n *\n * @param {RegExp} pattern\n * @param {string|Function} message\n *\n * @example\n *\n * const zipValidators = [regex(/^\\d{5}(?:[-\\s]\\d{4})?$/, 'Must be a zip code')];\n * <TextInput name=\"zip\" validate={zipValidators} />\n */\n\nexport var regex = lodashMemoize(function (pattern, message) {\n  if (message === void 0) {\n    message = 'ra.validation.regex';\n  }\n\n  return function (value, values) {\n    return !isEmpty(value) && typeof value === 'string' && !pattern.test(value) ? getMessage(message, {\n      pattern: pattern\n    }, value, values) : undefined;\n  };\n}, function (pattern, message) {\n  return pattern.toString() + message;\n});\n/**\n * Email validator\n *\n * Returns an error if the value is not a valid email\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const emailValidators = [email('Must be an email')];\n * <TextInput name=\"email\" validate={emailValidators} />\n */\n\nexport var email = memoize(function (message) {\n  if (message === void 0) {\n    message = 'ra.validation.email';\n  }\n\n  return regex(EMAIL_REGEX, message);\n});\n\nvar oneOfTypeMessage = function (_a) {\n  var args = _a.args;\n  return {\n    message: 'ra.validation.oneOf',\n    args: args\n  };\n};\n/**\n * Choices validator\n *\n * Returns an error if the value is not among the list passed as parameter\n *\n * @param {array} list\n * @param {string|Function} message\n *\n * @example\n *\n * const genderValidators = [choices(['male', 'female'], 'Must be either Male or Female')];\n * <TextInput name=\"gender\" validate={genderValidators} />\n */\n\n\nexport var choices = memoize(function (list, message) {\n  if (message === void 0) {\n    message = oneOfTypeMessage;\n  }\n\n  return function (value, values) {\n    return !isEmpty(value) && list.indexOf(value) === -1 ? getMessage(message, {\n      list: list\n    }, value, values) : undefined;\n  };\n});\n/**\n * Given a validator, returns a boolean indicating whether the field is required or not.\n */\n\nexport var isRequired = function (validate) {\n  if (validate && validate.isRequired) {\n    return true;\n  }\n\n  if (Array.isArray(validate)) {\n    return !!validate.find(function (it) {\n      return it.isRequired;\n    });\n  }\n\n  return false;\n};","map":{"version":3,"mappings":"AAAA,OAAOA,aAAP,MAA0B,gBAA1B;AAEA;;AACA;;AACA,IAAMC,WAAW,GAAG,wJAApB,C,CAA8K;;AAE9K,IAAMC,OAAO,GAAG,UAACC,KAAD,EAAW;EACvB,cAAOA,KAAP,KAAiB,WAAjB,IACAA,KAAK,KAAK,IADV,IAEAA,KAAK,KAAK,EAFV,IAGCC,KAAK,CAACC,OAAN,CAAcF,KAAd,KAAwBA,KAAK,CAACG,MAAN,KAAiB,CAH1C;AAG4C,CAJhD,C,CAyBA;;;AACA,SAASC,gCAAT,CACIC,KADJ,EACgC;EAE5B,OAAOA,KAAK,GAAGA,KAAK,CAACC,cAAN,CAAqB,SAArB,CAAH,GAAqC,KAAjD;AACH;;AAUD,IAAMC,UAAU,GAAG,UACfC,OADe,EAEfC,WAFe,EAGfT,KAHe,EAIfU,MAJe,EAIJ;EAEX,cAAOF,OAAP,KAAmB,UAAnB,GACMA,OAAO,CAAC;IACJG,IAAI,EAAEF,WADF;IAEJT,KAAK,OAFD;IAGJU,MAAM;EAHF,CAAD,CADb,GAMMD,WAAW,GACX;IACID,OAAO,SADX;IAEIG,IAAI,EAAEF;EAFV,CADW,GAKXD,OAXN;AAWa,CAjBjB,C,CAwBA;AACA;AACA;;;AACA,IAAMI,OAAO,GAAY,UAACC,EAAD,EAAQ;EAC7B,oBAAa,CAACA,EAAD,EAAK;IAAC;;SAAA,yCAAO;MAAPF;;;IAAY,WAAI,CAACG,SAAL,CAAeH,IAAf;EAAoB,CAAtC,CAAb;AAAoD,CADxD;;AAGA,IAAMI,UAAU,GAAG,iBAAK;EAAI,cAAOf,KAAP,KAAiB,UAAjB;AAA2B,CAAvD;;AAEA,OAAO,IAAMgB,kBAAkB,GAAG,UAC9BC,UAD8B,EAE9BC,UAF8B,EAET;EAErB,OAAO,UAAClB,KAAD,EAAQU,MAAR,EAAgBS,IAAhB,EAAoB;IACvB,IAAMC,OAAO,GAAGH,UAAU,CAACjB,KAAD,EAAQU,MAAR,EAAgBS,IAAhB,CAA1B;;IACA,IAAI,CAACC,OAAL,EAAc;MACV,OAAOF,UAAU,CAAClB,KAAD,EAAQU,MAAR,EAAgBS,IAAhB,CAAjB;IACH;;IACD,IACI,OAAOC,OAAP,KAAmB,QAAnB,IACAhB,gCAAgC,CAACgB,OAAD,CAFpC,EAGE;MACE,OAAOA,OAAP;IACH;;IAED,OAAOA,OAAO,CAACC,IAAR,CAAa,2BAAe;MAC/B,IAAI,CAACC,eAAL,EAAsB;QAClB,OAAOJ,UAAU,CAAClB,KAAD,EAAQU,MAAR,EAAgBS,IAAhB,CAAjB;MACH;;MACD,OAAOG,eAAP;IACH,CALM,CAAP;EAMH,CAlBD;AAmBH,CAvBM,C,CAyBP;;AACA,OAAO,IAAMC,iBAAiB,GAAG;EAAC;;OAAA,yCAAa;IAAbC;;;EAC9B,IAAMC,aAAa,GAAG,CAACxB,KAAK,CAACC,OAAN,CAAcsB,UAAU,CAAC,CAAD,CAAxB,IACjBA,UAAU,CAAC,CAAD,CADO,GAEjBA,UAFgB,EAGpBE,MAHoB,CAGbX,UAHa,CAAtB;EAIA,OAAOU,aAAa,CAACE,MAAd,CAAqBX,kBAArB,EAAyC;IAAM;EAAI,CAAnD,CAAP;AACH,CANM,C,CAQP;;AACA,OAAO,IAAMY,qBAAqB,GAAG;EAAC;;OAAA,yCAAa;IAAbJ;;;EAAkB,iBACpDxB,KADoD,EAEpDU,MAFoD,EAGpDS,IAHoD,EAGhD;IAEJ,IAAMM,aAAa,GAAG,CAACxB,KAAK,CAACC,OAAN,CAAcsB,UAAU,CAAC,CAAD,CAAxB,IACjBA,UAAU,CAAC,CAAD,CADO,GAEjBA,UAFgB,EAGpBE,MAHoB,CAGbX,UAHa,CAAtB;;IAKA,KAAwB,2CAAxB,EAAwBc,2BAAxB,EAAwBA,IAAxB,EAAuC;MAAlC,IAAMC,SAAS,sBAAf;MACD,IAAMzB,KAAK,GAAGyB,SAAS,CAAC9B,KAAD,EAAQU,MAAR,EAAgBS,IAAhB,CAAvB;;MAEA,IAAId,KAAJ,EAAW;QACP,OAAOA,KAAP;MACH;IACJ;EACJ,CAjBuD;AAiBvD,CAjBM;AAmBP;;;;;;;;;;;;;AAYA,OAAO,IAAM0B,QAAQ,GAAGnB,OAAO,CAAC,UAACJ,OAAD,EAAmC;EAAlC;IAAAA;EAAkC;;EAC/D,aAAM,CAACwB,MAAP,CACI,UAAChC,KAAD,EAAQU,MAAR,EAAc;IACV,cAAO,CAACV,KAAD,CAAP,GACMO,UAAU,CAACC,OAAD,EAAUyB,SAAV,EAAqBjC,KAArB,EAA4BU,MAA5B,CADhB,GAEMuB,SAFN;EAEe,CAJvB,EAKI;IAAEC,UAAU,EAAE;EAAd,CALJ;AAMC,CAP0B,CAAxB;AAUP;;;;;;;;;;;;;;AAaA,OAAO,IAAMC,SAAS,GAAGvB,OAAO,CAC5B,UAACwB,GAAD,EAAM5B,OAAN,EAAyC;EAAnC;IAAAA;EAAmC;;EAAK,iBAACR,KAAD,EAAQU,MAAR,EAAc;IACxD,QAACX,OAAO,CAACC,KAAD,CAAR,IAAmBA,KAAK,CAACG,MAAN,GAAeiC,GAAlC,GACM7B,UAAU,CAACC,OAAD,EAAU;MAAE4B,GAAG;IAAL,CAAV,EAAmBpC,KAAnB,EAA0BU,MAA1B,CADhB,GAEMuB,SAFN;EAEe,CAH2B;AAG3B,CAJS,CAAzB;AAOP;;;;;;;;;;;;;;AAaA,OAAO,IAAMI,SAAS,GAAGzB,OAAO,CAC5B,UAAC0B,GAAD,EAAM9B,OAAN,EAAyC;EAAnC;IAAAA;EAAmC;;EAAK,iBAACR,KAAD,EAAQU,MAAR,EAAc;IACxD,QAACX,OAAO,CAACC,KAAD,CAAR,IAAmBA,KAAK,CAACG,MAAN,GAAemC,GAAlC,GACM/B,UAAU,CAACC,OAAD,EAAU;MAAE8B,GAAG;IAAL,CAAV,EAAmBtC,KAAnB,EAA0BU,MAA1B,CADhB,GAEMuB,SAFN;EAEe,CAH2B;AAG3B,CAJS,CAAzB;AAOP;;;;;;;;;;;;;;AAaA,OAAO,IAAMM,QAAQ,GAAG3B,OAAO,CAC3B,UAACwB,GAAD,EAAM5B,OAAN,EAAwC;EAAlC;IAAAA;EAAkC;;EAAK,iBAACR,KAAD,EAAQU,MAAR,EAAc;IACvD,QAACX,OAAO,CAACC,KAAD,CAAR,IAAmBA,KAAK,GAAGoC,GAA3B,GACM7B,UAAU,CAACC,OAAD,EAAU;MAAE4B,GAAG;IAAL,CAAV,EAAmBpC,KAAnB,EAA0BU,MAA1B,CADhB,GAEMuB,SAFN;EAEe,CAH0B;AAG1B,CAJQ,CAAxB;AAOP;;;;;;;;;;;;;;AAaA,OAAO,IAAMO,QAAQ,GAAG5B,OAAO,CAC3B,UAAC0B,GAAD,EAAM9B,OAAN,EAAwC;EAAlC;IAAAA;EAAkC;;EAAK,iBAACR,KAAD,EAAQU,MAAR,EAAc;IACvD,QAACX,OAAO,CAACC,KAAD,CAAR,IAAmBA,KAAK,GAAGsC,GAA3B,GACM/B,UAAU,CAACC,OAAD,EAAU;MAAE8B,GAAG;IAAL,CAAV,EAAmBtC,KAAnB,EAA0BU,MAA1B,CADhB,GAEMuB,SAFN;EAEe,CAH0B;AAG1B,CAJQ,CAAxB;AAOP;;;;;;;;;;;;;AAYA,OAAO,IAAMQ,MAAM,GAAG7B,OAAO,CACzB,UAACJ,OAAD,EAAiC;EAAhC;IAAAA;EAAgC;;EAAK,iBAACR,KAAD,EAAQU,MAAR,EAAc;IAChD,QAACX,OAAO,CAACC,KAAD,CAAR,IAAmB0C,KAAK,CAACC,MAAM,CAAC3C,KAAD,CAAP,CAAxB,GACMO,UAAU,CAACC,OAAD,EAAUyB,SAAV,EAAqBjC,KAArB,EAA4BU,MAA5B,CADhB,GAEMuB,SAFN;EAEe,CAHmB;AAGnB,CAJM,CAAtB;AAOP;;;;;;;;;;;;;;AAaA,OAAO,IAAMW,KAAK,GAAG/C,aAAa,CAC9B,UAACgD,OAAD,EAAUrC,OAAV,EAAyC;EAA/B;IAAAA;EAA+B;;EAAK,iBAACR,KAAD,EAAQU,MAAR,EAAe;IACzD,QAACX,OAAO,CAACC,KAAD,CAAR,IAAmB,OAAOA,KAAP,KAAiB,QAApC,IAAgD,CAAC6C,OAAO,CAACC,IAAR,CAAa9C,KAAb,CAAjD,GACMO,UAAU,CAACC,OAAD,EAAU;MAAEqC,OAAO;IAAT,CAAV,EAAuB7C,KAAvB,EAA8BU,MAA9B,CADhB,GAEMuB,SAFN;EAEe,CAH2B;AAG3B,CAJW,EAK9B,UAACY,OAAD,EAAUrC,OAAV,EAAiB;EACb,OAAOqC,OAAO,CAACE,QAAR,KAAqBvC,OAA5B;AACH,CAP6B,CAA3B;AAUP;;;;;;;;;;;;;AAYA,OAAO,IAAMwC,KAAK,GAAGpC,OAAO,CAAC,UAACJ,OAAD,EAAgC;EAA/B;IAAAA;EAA+B;;EACzD,YAAK,CAACV,WAAD,EAAcU,OAAd,CAAL;AAA2B,CADH,CAArB;;AAIP,IAAMyC,gBAAgB,GAAgB,UAACC,EAAD,EAAS;MAANvC,IAAI;EAAO,OAAC;IACjDH,OAAO,EAAE,qBADwC;IAEjDG,IAAI;EAF6C,CAAD;AAGlD,CAHF;AAKA;;;;;;;;;;;;;;;AAaA,OAAO,IAAMwC,OAAO,GAAGvC,OAAO,CAC1B,UAACwC,IAAD,EAAO5C,OAAP,EAAiC;EAA1B;IAAAA;EAA0B;;EAAK,iBAACR,KAAD,EAAQU,MAAR,EAAc;IAChD,QAACX,OAAO,CAACC,KAAD,CAAR,IAAmBoD,IAAI,CAACC,OAAL,CAAarD,KAAb,MAAwB,CAAC,CAA5C,GACMO,UAAU,CAACC,OAAD,EAAU;MAAE4C,IAAI;IAAN,CAAV,EAAoBpD,KAApB,EAA2BU,MAA3B,CADhB,GAEMuB,SAFN;EAEe,CAHmB;AAGnB,CAJO,CAAvB;AAOP;;;;AAGA,OAAO,IAAMC,UAAU,GAAG,oBAAQ;EAC9B,IAAIoB,QAAQ,IAAIA,QAAQ,CAACpB,UAAzB,EAAqC;IACjC,OAAO,IAAP;EACH;;EACD,IAAIjC,KAAK,CAACC,OAAN,CAAcoD,QAAd,CAAJ,EAA6B;IACzB,OAAO,CAAC,CAACA,QAAQ,CAACC,IAAT,CAAc,cAAE;MAAI,SAAE,CAACrB,UAAH;IAAa,CAAjC,CAAT;EACH;;EACD,OAAO,KAAP;AACH,CARM","names":["lodashMemoize","EMAIL_REGEX","isEmpty","value","Array","isArray","length","isValidationErrorMessageWithArgs","error","hasOwnProperty","getMessage","message","messageArgs","values","args","memoize","fn","stringify","isFunction","combine2Validators","validator1","validator2","meta","result1","then","resolvedResult1","composeValidators","validators","allValidators","filter","reduce","composeSyncValidators","_i","validator","required","assign","undefined","isRequired","minLength","min","maxLength","max","minValue","maxValue","number","isNaN","Number","regex","pattern","test","toString","email","oneOfTypeMessage","_a","choices","list","indexOf","validate","find"],"sources":["/var/www/a1boots/node_modules/ra-core/src/form/validate.ts"],"sourcesContent":["import lodashMemoize from 'lodash/memoize';\n\n/* eslint-disable no-underscore-dangle */\n/* @link http://stackoverflow.com/questions/46155/validate-email-address-in-javascript */\nconst EMAIL_REGEX = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; // eslint-disable-line no-useless-escape\n\nconst isEmpty = (value: any) =>\n    typeof value === 'undefined' ||\n    value === null ||\n    value === '' ||\n    (Array.isArray(value) && value.length === 0);\n\nexport interface ValidationErrorMessageWithArgs {\n    message: string;\n    args: {\n        [key: string]: ValidationErrorMessageWithArgs | any;\n    };\n}\n\nexport type ValidationErrorMessage = string | ValidationErrorMessageWithArgs;\n\nexport type Validator = (\n    value: any,\n    values: any,\n    props: any\n) =>\n    | ValidationErrorMessage\n    | null\n    | undefined\n    | Promise<ValidationErrorMessage | null | undefined>;\n\n// type predicate, see https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates\nfunction isValidationErrorMessageWithArgs(\n    error: ReturnType<Validator>\n): error is ValidationErrorMessageWithArgs {\n    return error ? error.hasOwnProperty('message') : false;\n}\n\ninterface MessageFuncParams {\n    args: any;\n    value: any;\n    values: any;\n}\n\ntype MessageFunc = (params: MessageFuncParams) => ValidationErrorMessage;\n\nconst getMessage = (\n    message: string | MessageFunc,\n    messageArgs: any,\n    value: any,\n    values: any\n) =>\n    typeof message === 'function'\n        ? message({\n              args: messageArgs,\n              value,\n              values,\n          })\n        : messageArgs\n        ? {\n              message,\n              args: messageArgs,\n          }\n        : message;\n\ntype Memoize = <T extends (...args: any[]) => any>(\n    func: T,\n    resolver?: (...args: any[]) => any\n) => T;\n\n// If we define validation functions directly in JSX, it will\n// result in a new function at every render, and then trigger infinite re-render.\n// Hence, we memoize every built-in validator to prevent a \"Maximum call stack\" error.\nconst memoize: Memoize = (fn: any) =>\n    lodashMemoize(fn, (...args) => JSON.stringify(args));\n\nconst isFunction = value => typeof value === 'function';\n\nexport const combine2Validators = (\n    validator1: Validator,\n    validator2: Validator\n): Validator => {\n    return (value, values, meta) => {\n        const result1 = validator1(value, values, meta);\n        if (!result1) {\n            return validator2(value, values, meta);\n        }\n        if (\n            typeof result1 === 'string' ||\n            isValidationErrorMessageWithArgs(result1)\n        ) {\n            return result1;\n        }\n\n        return result1.then(resolvedResult1 => {\n            if (!resolvedResult1) {\n                return validator2(value, values, meta);\n            }\n            return resolvedResult1;\n        });\n    };\n};\n\n// Compose multiple validators into a single one for use with react-hook-form\nexport const composeValidators = (...validators) => {\n    const allValidators = (Array.isArray(validators[0])\n        ? validators[0]\n        : validators\n    ).filter(isFunction) as Validator[];\n    return allValidators.reduce(combine2Validators, () => null);\n};\n\n// Compose multiple validators into a single one for use with react-hook-form\nexport const composeSyncValidators = (...validators) => (\n    value,\n    values,\n    meta\n) => {\n    const allValidators = (Array.isArray(validators[0])\n        ? validators[0]\n        : validators\n    ).filter(isFunction) as Validator[];\n\n    for (const validator of allValidators) {\n        const error = validator(value, values, meta);\n\n        if (error) {\n            return error;\n        }\n    }\n};\n\n/**\n * Required validator\n *\n * Returns an error if the value is null, undefined, or empty\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const titleValidators = [required('The title is required')];\n * <TextInput name=\"title\" validate={titleValidators} />\n */\nexport const required = memoize((message = 'ra.validation.required') =>\n    Object.assign(\n        (value, values) =>\n            isEmpty(value)\n                ? getMessage(message, undefined, value, values)\n                : undefined,\n        { isRequired: true }\n    )\n);\n\n/**\n * Minimum length validator\n *\n * Returns an error if the value has a length less than the parameter\n *\n * @param {integer} min\n * @param {string|Function} message\n *\n * @example\n *\n * const passwordValidators = [minLength(10, 'Should be at least 10 characters')];\n * <TextInput type=\"password\" name=\"password\" validate={passwordValidators} />\n */\nexport const minLength = memoize(\n    (min, message = 'ra.validation.minLength') => (value, values) =>\n        !isEmpty(value) && value.length < min\n            ? getMessage(message, { min }, value, values)\n            : undefined\n);\n\n/**\n * Maximum length validator\n *\n * Returns an error if the value has a length higher than the parameter\n *\n * @param {integer} max\n * @param {string|Function} message\n *\n * @example\n *\n * const nameValidators = [maxLength(10, 'Should be at most 10 characters')];\n * <TextInput name=\"name\" validate={nameValidators} />\n */\nexport const maxLength = memoize(\n    (max, message = 'ra.validation.maxLength') => (value, values) =>\n        !isEmpty(value) && value.length > max\n            ? getMessage(message, { max }, value, values)\n            : undefined\n);\n\n/**\n * Minimum validator\n *\n * Returns an error if the value is less than the parameter\n *\n * @param {integer} min\n * @param {string|Function} message\n *\n * @example\n *\n * const fooValidators = [minValue(5, 'Should be more than 5')];\n * <NumberInput name=\"foo\" validate={fooValidators} />\n */\nexport const minValue = memoize(\n    (min, message = 'ra.validation.minValue') => (value, values) =>\n        !isEmpty(value) && value < min\n            ? getMessage(message, { min }, value, values)\n            : undefined\n);\n\n/**\n * Maximum validator\n *\n * Returns an error if the value is higher than the parameter\n *\n * @param {integer} max\n * @param {string|Function} message\n *\n * @example\n *\n * const fooValidators = [maxValue(10, 'Should be less than 10')];\n * <NumberInput name=\"foo\" validate={fooValidators} />\n */\nexport const maxValue = memoize(\n    (max, message = 'ra.validation.maxValue') => (value, values) =>\n        !isEmpty(value) && value > max\n            ? getMessage(message, { max }, value, values)\n            : undefined\n);\n\n/**\n * Number validator\n *\n * Returns an error if the value is not a number\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const ageValidators = [number('Must be a number')];\n * <TextInput name=\"age\" validate={ageValidators} />\n */\nexport const number = memoize(\n    (message = 'ra.validation.number') => (value, values) =>\n        !isEmpty(value) && isNaN(Number(value))\n            ? getMessage(message, undefined, value, values)\n            : undefined\n);\n\n/**\n * Regular expression validator\n *\n * Returns an error if the value does not match the pattern given as parameter\n *\n * @param {RegExp} pattern\n * @param {string|Function} message\n *\n * @example\n *\n * const zipValidators = [regex(/^\\d{5}(?:[-\\s]\\d{4})?$/, 'Must be a zip code')];\n * <TextInput name=\"zip\" validate={zipValidators} />\n */\nexport const regex = lodashMemoize(\n    (pattern, message = 'ra.validation.regex') => (value, values?) =>\n        !isEmpty(value) && typeof value === 'string' && !pattern.test(value)\n            ? getMessage(message, { pattern }, value, values)\n            : undefined,\n    (pattern, message) => {\n        return pattern.toString() + message;\n    }\n);\n\n/**\n * Email validator\n *\n * Returns an error if the value is not a valid email\n *\n * @param {string|Function} message\n *\n * @example\n *\n * const emailValidators = [email('Must be an email')];\n * <TextInput name=\"email\" validate={emailValidators} />\n */\nexport const email = memoize((message = 'ra.validation.email') =>\n    regex(EMAIL_REGEX, message)\n);\n\nconst oneOfTypeMessage: MessageFunc = ({ args }) => ({\n    message: 'ra.validation.oneOf',\n    args,\n});\n\n/**\n * Choices validator\n *\n * Returns an error if the value is not among the list passed as parameter\n *\n * @param {array} list\n * @param {string|Function} message\n *\n * @example\n *\n * const genderValidators = [choices(['male', 'female'], 'Must be either Male or Female')];\n * <TextInput name=\"gender\" validate={genderValidators} />\n */\nexport const choices = memoize(\n    (list, message = oneOfTypeMessage) => (value, values) =>\n        !isEmpty(value) && list.indexOf(value) === -1\n            ? getMessage(message, { list }, value, values)\n            : undefined\n);\n\n/**\n * Given a validator, returns a boolean indicating whether the field is required or not.\n */\nexport const isRequired = validate => {\n    if (validate && validate.isRequired) {\n        return true;\n    }\n    if (Array.isArray(validate)) {\n        return !!validate.find(it => it.isRequired);\n    }\n    return false;\n};\n"]},"metadata":{},"sourceType":"module"}