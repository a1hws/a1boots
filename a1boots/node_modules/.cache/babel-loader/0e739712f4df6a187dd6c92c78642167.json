{"ast":null,"code":"import * as React from 'react';\nimport { useEffect, useRef } from 'react';\nimport { useInfinitePaginationContext, useListContext, useEvent } from 'ra-core';\nimport { Box, CircularProgress } from '@mui/material';\n/**\n * A pagination component that loads more results when the user scrolls to the bottom of the list.\n *\n * Used as the default pagination component in the <InfiniteList> component.\n *\n * @example\n * import { InfiniteList, InfinitePagination, Datagrid, TextField } from 'react-admin';\n *\n * const PostList = () => (\n *    <InfiniteList pagination={<InfinitePagination sx={{ py: 5 }} />}>\n *       <Datagrid>\n *          <TextField source=\"id\" />\n *         <TextField source=\"title\" />\n *      </Datagrid>\n *   </InfiniteList>\n * );\n */\n\nexport var InfinitePagination = function (_a) {\n  var _b = _a.options,\n      options = _b === void 0 ? defaultOptions : _b,\n      sx = _a.sx;\n  var isLoading = useListContext().isLoading;\n\n  var _c = useInfinitePaginationContext(),\n      fetchNextPage = _c.fetchNextPage,\n      hasNextPage = _c.hasNextPage,\n      isFetchingNextPage = _c.isFetchingNextPage;\n\n  if (!fetchNextPage) {\n    throw new Error('InfinitePagination must be used inside an InfinitePaginationContext, usually created by <InfiniteList>. You cannot use it as child of a <List> component.');\n  }\n\n  var observerElem = useRef(null);\n  var handleObserver = useEvent(function (entries) {\n    var target = entries[0];\n\n    if (target.isIntersecting && hasNextPage && !isFetchingNextPage) {\n      fetchNextPage();\n    }\n  });\n  useEffect(function () {\n    var element = observerElem.current;\n    if (!element) return;\n    var observer = new IntersectionObserver(handleObserver, options);\n    observer.observe(element);\n    return function () {\n      return observer.unobserve(element);\n    };\n  }, [fetchNextPage, hasNextPage, handleObserver, options, isLoading, isFetchingNextPage]);\n  if (isLoading) return null;\n  return React.createElement(Box, {\n    ref: observerElem,\n    py: 2,\n    textAlign: \"center\",\n    sx: sx\n  }, isFetchingNextPage && hasNextPage && React.createElement(CircularProgress, {\n    size: \"1.5em\"\n  }));\n};\nvar defaultOptions = {\n  threshold: 0\n};","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,SAAT,EAAoBC,MAApB,QAAkC,OAAlC;AACA,SACIC,4BADJ,EAEIC,cAFJ,EAGIC,QAHJ,QAIO,SAJP;AAKA,SAASC,GAAT,EAAcC,gBAAd,QAA+C,eAA/C;AAEA;;;;;;;;;;;;;;;;;;AAiBA,OAAO,IAAMC,kBAAkB,GAAG,UAACC,EAAD,EAGR;MAFtBC;MAAAC,OAAO,mBAAGC,cAAH,GAAiBF;MACxBG,EAAE;EAEM,aAAS,GAAKT,cAAc,GAAEU,SAA9B;;EACF,SAIFX,4BAA4B,EAJ1B;EAAA,IACFY,aAAa,mBADX;EAAA,IAEFC,WAAW,iBAFT;EAAA,IAGFC,kBAAkB,wBAHhB;;EAMN,IAAI,CAACF,aAAL,EAAoB;IAChB,MAAM,IAAIG,KAAJ,CACF,2JADE,CAAN;EAGH;;EAED,IAAMC,YAAY,GAAGjB,MAAM,CAAC,IAAD,CAA3B;EAEA,IAAMkB,cAAc,GAAGf,QAAQ,CAC3B,mBAAO;IACI,UAAM,GAAIgB,OAAO,GAAjB;;IACP,IAAIC,MAAM,CAACC,cAAP,IAAyBP,WAAzB,IAAwC,CAACC,kBAA7C,EAAiE;MAC7DF,aAAa;IAChB;EACJ,CAN0B,CAA/B;EASAd,SAAS,CAAC;IACN,IAAMuB,OAAO,GAAGL,YAAY,CAACM,OAA7B;IACA,IAAI,CAACD,OAAL,EAAc;IACd,IAAME,QAAQ,GAAG,IAAIC,oBAAJ,CAAyBP,cAAzB,EAAyCT,OAAzC,CAAjB;IACAe,QAAQ,CAACE,OAAT,CAAiBJ,OAAjB;IACA,OAAO;MAAM,eAAQ,CAACK,SAAT,CAAmBL,OAAnB;IAA2B,CAAxC;EACH,CANQ,EAMN,CACCT,aADD,EAECC,WAFD,EAGCI,cAHD,EAICT,OAJD,EAKCG,SALD,EAMCG,kBAND,CANM,CAAT;EAeA,IAAIH,SAAJ,EAAe,OAAO,IAAP;EAEf,OACId,oBAACM,GAAD,EAAI;IAACwB,GAAG,EAAEX,YAAN;IAAoBY,EAAE,EAAE,CAAxB;IAA2BC,SAAS,EAAC,QAArC;IAA8CnB,EAAE,EAAEA;EAAlD,CAAJ,EACKI,kBAAkB,IAAID,WAAtB,IACGhB,oBAACO,gBAAD,EAAiB;IAAC0B,IAAI,EAAC;EAAN,CAAjB,CAFR,CADJ;AAOH,CApDM;AAsDP,IAAMrB,cAAc,GAAG;EAAEsB,SAAS,EAAE;AAAb,CAAvB","names":["React","useEffect","useRef","useInfinitePaginationContext","useListContext","useEvent","Box","CircularProgress","InfinitePagination","_a","_b","options","defaultOptions","sx","isLoading","fetchNextPage","hasNextPage","isFetchingNextPage","Error","observerElem","handleObserver","entries","target","isIntersecting","element","current","observer","IntersectionObserver","observe","unobserve","ref","py","textAlign","size","threshold"],"sources":["/var/www/a1boots/node_modules/ra-ui-materialui/src/list/pagination/InfinitePagination.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useEffect, useRef } from 'react';\nimport {\n    useInfinitePaginationContext,\n    useListContext,\n    useEvent,\n} from 'ra-core';\nimport { Box, CircularProgress, SxProps } from '@mui/material';\n\n/**\n * A pagination component that loads more results when the user scrolls to the bottom of the list.\n *\n * Used as the default pagination component in the <InfiniteList> component.\n *\n * @example\n * import { InfiniteList, InfinitePagination, Datagrid, TextField } from 'react-admin';\n *\n * const PostList = () => (\n *    <InfiniteList pagination={<InfinitePagination sx={{ py: 5 }} />}>\n *       <Datagrid>\n *          <TextField source=\"id\" />\n *         <TextField source=\"title\" />\n *      </Datagrid>\n *   </InfiniteList>\n * );\n */\nexport const InfinitePagination = ({\n    options = defaultOptions,\n    sx,\n}: InfinitePaginationProps) => {\n    const { isLoading } = useListContext();\n    const {\n        fetchNextPage,\n        hasNextPage,\n        isFetchingNextPage,\n    } = useInfinitePaginationContext();\n\n    if (!fetchNextPage) {\n        throw new Error(\n            'InfinitePagination must be used inside an InfinitePaginationContext, usually created by <InfiniteList>. You cannot use it as child of a <List> component.'\n        );\n    }\n\n    const observerElem = useRef(null);\n\n    const handleObserver = useEvent<[IntersectionObserverEntry[]], void>(\n        entries => {\n            const [target] = entries;\n            if (target.isIntersecting && hasNextPage && !isFetchingNextPage) {\n                fetchNextPage();\n            }\n        }\n    );\n\n    useEffect(() => {\n        const element = observerElem.current;\n        if (!element) return;\n        const observer = new IntersectionObserver(handleObserver, options);\n        observer.observe(element);\n        return () => observer.unobserve(element);\n    }, [\n        fetchNextPage,\n        hasNextPage,\n        handleObserver,\n        options,\n        isLoading,\n        isFetchingNextPage,\n    ]);\n\n    if (isLoading) return null;\n\n    return (\n        <Box ref={observerElem} py={2} textAlign=\"center\" sx={sx}>\n            {isFetchingNextPage && hasNextPage && (\n                <CircularProgress size=\"1.5em\" />\n            )}\n        </Box>\n    );\n};\n\nconst defaultOptions = { threshold: 0 };\n\nexport interface InfinitePaginationProps {\n    options?: IntersectionObserverInit;\n    sx?: SxProps;\n}\n"]},"metadata":{},"sourceType":"module"}