{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { useEffect } from 'react';\nimport { useController } from 'react-hook-form';\nimport get from 'lodash/get';\nimport { useRecordContext } from '../controller';\nimport { composeValidators } from './validate';\nimport isRequired from './isRequired';\nimport { useFormGroupContext } from './useFormGroupContext';\nimport { useGetValidationErrorMessage } from './useGetValidationErrorMessage';\nimport { useFormGroups } from './useFormGroups';\nimport { useApplyInputDefaultValues } from './useApplyInputDefaultValues';\nimport { useEvent } from '../util'; // replace null or undefined values by empty string to avoid controlled/uncontrolled input warning\n\nvar defaultFormat = function defaultFormat(value) {\n  return value == null ? '' : value;\n}; // parse empty string into null as it's more suitable for a majority of backends\n\n\nvar defaultParse = function defaultParse(value) {\n  return value === '' ? null : value;\n};\n\nexport var useInput = function useInput(props) {\n  var defaultValue = props.defaultValue,\n      _a = props.format,\n      format = _a === void 0 ? defaultFormat : _a,\n      id = props.id,\n      isRequiredOption = props.isRequired,\n      name = props.name,\n      initialOnBlur = props.onBlur,\n      initialOnChange = props.onChange,\n      _b = props.parse,\n      parse = _b === void 0 ? defaultParse : _b,\n      source = props.source,\n      validate = props.validate,\n      options = __rest(props, [\"defaultValue\", \"format\", \"id\", \"isRequired\", \"name\", \"onBlur\", \"onChange\", \"parse\", \"source\", \"validate\"]);\n\n  var finalName = name || source;\n  var formGroupName = useFormGroupContext();\n  var formGroups = useFormGroups();\n  var record = useRecordContext();\n  var getValidationErrorMessage = useGetValidationErrorMessage();\n  useEffect(function () {\n    if (!formGroups || formGroupName == null) {\n      return;\n    }\n\n    formGroups.registerField(source, formGroupName);\n    return function () {\n      formGroups.unregisterField(source, formGroupName);\n    };\n  }, [formGroups, formGroupName, source]);\n  var sanitizedValidate = Array.isArray(validate) ? composeValidators(validate) : validate; // Fetch the defaultValue from the record if available or apply the provided defaultValue.\n  // This ensures dynamically added inputs have their value set correctly (ArrayInput for example).\n  // We don't do this for the form level defaultValues so that it works as it should in react-hook-form\n  // (i.e. field level defaultValue override form level defaultValues for this field).\n\n  var _c = useController(__assign({\n    name: finalName,\n    defaultValue: get(record, source, defaultValue),\n    rules: {\n      validate: function validate(value, values) {\n        return __awaiter(void 0, void 0, void 0, function () {\n          var error;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                if (!sanitizedValidate) return [2\n                /*return*/\n                , true];\n                return [4\n                /*yield*/\n                , sanitizedValidate(value, values, props)];\n\n              case 1:\n                error = _a.sent();\n                if (!error) return [2\n                /*return*/\n                , true];\n                return [2\n                /*return*/\n                , getValidationErrorMessage(error)];\n            }\n          });\n        });\n      }\n    }\n  }, options)),\n      controllerField = _c.field,\n      fieldState = _c.fieldState,\n      formState = _c.formState; // Because our forms may receive an asynchronously loaded record for instance,\n  // they may reset their default values which would override the input default value.\n  // This hook ensures that the input default value is applied when a new record is loaded but has\n  // no value for the input.\n\n\n  useApplyInputDefaultValues(props);\n  var onBlur = useEvent(function () {\n    var event = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      event[_i] = arguments[_i];\n    }\n\n    if (initialOnBlur) {\n      initialOnBlur.apply(void 0, event);\n    }\n\n    controllerField.onBlur();\n  });\n  var onChange = useEvent(function () {\n    var _a, _b, _c, _d, _e;\n\n    var event = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      event[_i] = arguments[_i];\n    }\n\n    if (initialOnChange) {\n      initialOnChange.apply(void 0, event);\n    }\n\n    var eventOrValue = props.type === 'checkbox' && ((_b = (_a = event[0]) === null || _a === void 0 ? void 0 : _a.target) === null || _b === void 0 ? void 0 : _b.value) === 'on' ? event[0].target.checked : (_e = (_d = (_c = event[0]) === null || _c === void 0 ? void 0 : _c.target) === null || _d === void 0 ? void 0 : _d.value) !== null && _e !== void 0 ? _e : event[0];\n    controllerField.onChange(parse ? parse(eventOrValue) : eventOrValue);\n  });\n\n  var field = __assign(__assign({}, controllerField), {\n    value: format ? format(controllerField.value) : controllerField.value,\n    onBlur: onBlur,\n    onChange: onChange\n  });\n\n  return {\n    id: id || source,\n    field: field,\n    fieldState: fieldState,\n    formState: formState,\n    isRequired: isRequiredOption || isRequired(validate)\n  };\n};","map":{"version":3,"mappings":"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","names":["useEffect","useController","get","useRecordContext","composeValidators","isRequired","useFormGroupContext","useGetValidationErrorMessage","useFormGroups","useApplyInputDefaultValues","useEvent","defaultFormat","value","defaultParse","useInput","props","_a","format","id","isRequiredOption","name","initialOnBlur","initialOnChange","_b","parse","source","validate","options","finalName","formGroupName","formGroups","record","getValidationErrorMessage","registerField","unregisterField","sanitizedValidate","Array","isArray","defaultValue","rules","values","error","controllerField","fieldState","formState","onBlur","event","onChange","eventOrValue","type","target","checked","_c","_d","_e","field"],"sources":["/var/www/a1boots/node_modules/ra-core/src/form/useInput.ts"],"sourcesContent":["import { ReactElement, useEffect } from 'react';\nimport {\n    ControllerFieldState,\n    ControllerRenderProps,\n    useController,\n    UseControllerProps,\n    UseControllerReturn,\n    UseFormStateReturn,\n} from 'react-hook-form';\nimport get from 'lodash/get';\n\nimport { useRecordContext } from '../controller';\nimport { composeValidators, Validator } from './validate';\nimport isRequired from './isRequired';\nimport { useFormGroupContext } from './useFormGroupContext';\nimport { useGetValidationErrorMessage } from './useGetValidationErrorMessage';\nimport { useFormGroups } from './useFormGroups';\nimport { useApplyInputDefaultValues } from './useApplyInputDefaultValues';\nimport { useEvent } from '../util';\n\n// replace null or undefined values by empty string to avoid controlled/uncontrolled input warning\nconst defaultFormat = (value: any) => (value == null ? '' : value);\n// parse empty string into null as it's more suitable for a majority of backends\nconst defaultParse = (value: string) => (value === '' ? null : value);\n\nexport const useInput = <ValueType = any>(\n    props: InputProps<ValueType>\n): UseInputValue => {\n    const {\n        defaultValue,\n        format = defaultFormat,\n        id,\n        isRequired: isRequiredOption,\n        name,\n        onBlur: initialOnBlur,\n        onChange: initialOnChange,\n        parse = defaultParse,\n        source,\n        validate,\n        ...options\n    } = props;\n    const finalName = name || source;\n    const formGroupName = useFormGroupContext();\n    const formGroups = useFormGroups();\n    const record = useRecordContext();\n    const getValidationErrorMessage = useGetValidationErrorMessage();\n\n    useEffect(() => {\n        if (!formGroups || formGroupName == null) {\n            return;\n        }\n\n        formGroups.registerField(source, formGroupName);\n\n        return () => {\n            formGroups.unregisterField(source, formGroupName);\n        };\n    }, [formGroups, formGroupName, source]);\n\n    const sanitizedValidate = Array.isArray(validate)\n        ? composeValidators(validate)\n        : validate;\n\n    // Fetch the defaultValue from the record if available or apply the provided defaultValue.\n    // This ensures dynamically added inputs have their value set correctly (ArrayInput for example).\n    // We don't do this for the form level defaultValues so that it works as it should in react-hook-form\n    // (i.e. field level defaultValue override form level defaultValues for this field).\n    const { field: controllerField, fieldState, formState } = useController({\n        name: finalName,\n        defaultValue: get(record, source, defaultValue),\n        rules: {\n            validate: async (value, values) => {\n                if (!sanitizedValidate) return true;\n                const error = await sanitizedValidate(value, values, props);\n\n                if (!error) return true;\n                return getValidationErrorMessage(error);\n            },\n        },\n        ...options,\n    });\n\n    // Because our forms may receive an asynchronously loaded record for instance,\n    // they may reset their default values which would override the input default value.\n    // This hook ensures that the input default value is applied when a new record is loaded but has\n    // no value for the input.\n    useApplyInputDefaultValues(props);\n\n    const onBlur = useEvent((...event: any[]) => {\n        if (initialOnBlur) {\n            initialOnBlur(...event);\n        }\n        controllerField.onBlur();\n    });\n\n    const onChange = useEvent((...event: any[]) => {\n        if (initialOnChange) {\n            initialOnChange(...event);\n        }\n        const eventOrValue = (props.type === 'checkbox' &&\n        event[0]?.target?.value === 'on'\n            ? event[0].target.checked\n            : event[0]?.target?.value ?? event[0]) as any;\n        controllerField.onChange(parse ? parse(eventOrValue) : eventOrValue);\n    });\n\n    const field = {\n        ...controllerField,\n        value: format ? format(controllerField.value) : controllerField.value,\n        onBlur,\n        onChange,\n    };\n\n    return {\n        id: id || source,\n        field,\n        fieldState,\n        formState,\n        isRequired: isRequiredOption || isRequired(validate),\n    };\n};\n\nexport type InputProps<ValueType = any> = Omit<\n    UseControllerProps,\n    'name' | 'defaultValue' | 'rules'\n> &\n    Partial<UseControllerReturn> & {\n        alwaysOn?: any;\n        defaultValue?: any;\n        format?: (value: ValueType) => any;\n        id?: string;\n        isRequired?: boolean;\n        label?: string | ReactElement | false;\n        helperText?: string | ReactElement | false;\n        name?: string;\n        onBlur?: (...event: any[]) => void;\n        onChange?: (...event: any[]) => void;\n        parse?: (value: any) => ValueType;\n        type?: string;\n        resource?: string;\n        source: string;\n        validate?: Validator | Validator[];\n    };\n\nexport type UseInputValue = {\n    id: string;\n    isRequired: boolean;\n    field: ControllerRenderProps;\n    formState: UseFormStateReturn<Record<string, string>>;\n    fieldState: ControllerFieldState;\n};\n"]},"metadata":{},"sourceType":"module"}