{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { useGetManyAggregate } from '../dataProvider';\n/**\n * @typedef UseReferenceResult\n * @type {Object}\n * @property {boolean} isFetching: boolean indicating if the reference is loading\n * @property {boolean} isLoading: boolean indicating if the reference has loaded at least once\n * @property {Object} referenceRecord: the referenced record.\n */\n\n/**\n * Fetch reference record, and return it when available\n *\n * The reference prop should be the name of one of the <Resource> components\n * added as <Admin> child.\n *\n * @example\n *\n * const { isLoading, referenceRecord } = useReference({\n *     id: 7,\n *     reference: 'users',\n * });\n *\n * @param {Object} option\n * @param {string} option.reference The linked resource name\n * @param {string} option.id The id of the reference\n * @param {Object} option.options Options passed to the dataProvider\n *\n * @returns {UseReferenceResult} The reference record\n */\n\nexport var useReference = function useReference(_a) {\n  var reference = _a.reference,\n      id = _a.id,\n      _b = _a.options,\n      options = _b === void 0 ? {} : _b;\n\n  var meta = options.meta,\n      otherQueryOptions = __rest(options, [\"meta\"]);\n\n  var _c = useGetManyAggregate(reference, {\n    ids: [id],\n    meta: meta\n  }, otherQueryOptions),\n      data = _c.data,\n      error = _c.error,\n      isLoading = _c.isLoading,\n      isFetching = _c.isFetching,\n      refetch = _c.refetch;\n\n  return {\n    referenceRecord: error ? undefined : data ? data[0] : undefined,\n    refetch: refetch,\n    error: error,\n    isLoading: isLoading,\n    isFetching: isFetching\n  };\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;AACA,SAA8BA,mBAA9B,QAAyD,iBAAzD;AAiBA;;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;AAoBA,OAAO,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAAyCC,EAAzC,EAII;MAH5BC,SAAS;MACTC,EAAE;MACFC;MAAAC,OAAO,mBAAG,EAAH,GAAKD;;EAEJ,QAAI,GAA2BC,OAAO,KAAtC;EAAA,IAASC,iBAAiB,UAAKD,OAAL,EAA5B,QAA4B,CAA1B;;EACF,SAAkDN,mBAAmB,CAEzEG,SAFyE,EAE9D;IAAEK,GAAG,EAAE,CAACJ,EAAD,CAAP;IAAaK,IAAI;EAAjB,CAF8D,EAEzCF,iBAFyC,CAArE;EAAA,IAAEG,IAAI,UAAN;EAAA,IAAQC,KAAK,WAAb;EAAA,IAAeC,SAAS,eAAxB;EAAA,IAA0BC,UAAU,gBAApC;EAAA,IAAsCC,OAAO,aAA7C;;EAGN,OAAO;IACHC,eAAe,EAAEJ,KAAK,GAAGK,SAAH,GAAeN,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAP,GAAaM,SADnD;IAEHF,OAAO,SAFJ;IAGHH,KAAK,OAHF;IAIHC,SAAS,WAJN;IAKHC,UAAU;EALP,CAAP;AAOH,CAhBM","names":["useGetManyAggregate","useReference","_a","reference","id","_b","options","otherQueryOptions","ids","meta","data","error","isLoading","isFetching","refetch","referenceRecord","undefined"],"sources":["/var/www/a1boots/node_modules/ra-core/src/controller/useReference.ts"],"sourcesContent":["import { RaRecord, Identifier } from '../types';\nimport { UseGetManyHookValue, useGetManyAggregate } from '../dataProvider';\nimport { UseQueryOptions } from 'react-query';\n\ninterface UseReferenceProps<RecordType extends RaRecord = any> {\n    id: Identifier;\n    reference: string;\n    options?: UseQueryOptions<RecordType[], Error> & { meta?: any };\n}\n\nexport interface UseReferenceResult<RecordType extends RaRecord = any> {\n    isLoading: boolean;\n    isFetching: boolean;\n    referenceRecord?: RecordType;\n    error?: any;\n    refetch: UseGetManyHookValue<RecordType>['refetch'];\n}\n\n/**\n * @typedef UseReferenceResult\n * @type {Object}\n * @property {boolean} isFetching: boolean indicating if the reference is loading\n * @property {boolean} isLoading: boolean indicating if the reference has loaded at least once\n * @property {Object} referenceRecord: the referenced record.\n */\n\n/**\n * Fetch reference record, and return it when available\n *\n * The reference prop should be the name of one of the <Resource> components\n * added as <Admin> child.\n *\n * @example\n *\n * const { isLoading, referenceRecord } = useReference({\n *     id: 7,\n *     reference: 'users',\n * });\n *\n * @param {Object} option\n * @param {string} option.reference The linked resource name\n * @param {string} option.id The id of the reference\n * @param {Object} option.options Options passed to the dataProvider\n *\n * @returns {UseReferenceResult} The reference record\n */\nexport const useReference = <RecordType extends RaRecord = RaRecord>({\n    reference,\n    id,\n    options = {},\n}: UseReferenceProps<RecordType>): UseReferenceResult<RecordType> => {\n    const { meta, ...otherQueryOptions } = options;\n    const { data, error, isLoading, isFetching, refetch } = useGetManyAggregate<\n        RecordType\n    >(reference, { ids: [id], meta }, otherQueryOptions);\n    return {\n        referenceRecord: error ? undefined : data ? data[0] : undefined,\n        refetch,\n        error,\n        isLoading,\n        isFetching,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}