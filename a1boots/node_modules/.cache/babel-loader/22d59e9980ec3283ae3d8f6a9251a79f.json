{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as React from 'react';\nimport { useCallback } from 'react';\nimport { styled } from '@mui/material/styles';\nimport PropTypes from 'prop-types';\nimport { Button, CircularProgress } from '@mui/material';\nimport ContentSave from '@mui/icons-material/Save';\nimport { useFormContext, useFormState } from 'react-hook-form';\nimport { useSaveContext, useTranslate, warning, setSubmissionErrors } from 'ra-core';\n/**\n * Submit button for resource forms (Edit and Create).\n *\n * @typedef {Object} Props the props you can use (other props are injected by the <Toolbar>)\n * @prop {string} className\n * @prop {string} label Button label. Defaults to 'ra.action.save', translated.\n * @prop {boolean} disabled Disable the button.\n * @prop {string} variant Material UI variant for the button. Defaults to 'contained'.\n * @prop {ReactElement} icon\n * @prop {function} mutationOptions Object of options passed to react-query.\n * @prop {function} transform Callback to execute before calling the dataProvider. Receives the data from the form, must return that transformed data. Can be asynchronous (and return a Promise)\n * @prop {boolean} alwaysEnable Force enabling the <SaveButton>. If it's not defined, the `<SaveButton>` will be enabled using `react-hook-form`'s `isValidating` state props and form context's `saving` prop (disabled if isValidating or saving, enabled otherwise).\n *\n * @param {Props} props\n *\n * @example // with custom success side effect\n *\n * const MySaveButton = props => {\n *     const notify = useNotify();\n *     const redirect = useRedirect();\n *     const onSuccess = (response) => {\n *         notify(`Post \"${response.data.title}\" saved!`);\n *         redirect('/posts');\n *     };\n *     return <SaveButton {...props} mutationOptions={{ onSuccess }} />;\n * }\n */\n\nexport var SaveButton = function (props) {\n  var _a = props.color,\n      color = _a === void 0 ? 'primary' : _a,\n      _b = props.icon,\n      icon = _b === void 0 ? defaultIcon : _b,\n      invalid = props.invalid,\n      _c = props.label,\n      label = _c === void 0 ? 'ra.action.save' : _c,\n      onClick = props.onClick,\n      mutationOptions = props.mutationOptions,\n      disabledProp = props.disabled,\n      _d = props.type,\n      type = _d === void 0 ? 'submit' : _d,\n      transform = props.transform,\n      _e = props.variant,\n      variant = _e === void 0 ? 'contained' : _e,\n      _f = props.alwaysEnable,\n      alwaysEnable = _f === void 0 ? false : _f,\n      rest = __rest(props, [\"color\", \"icon\", \"invalid\", \"label\", \"onClick\", \"mutationOptions\", \"disabled\", \"type\", \"transform\", \"variant\", \"alwaysEnable\"]);\n\n  var translate = useTranslate();\n  var form = useFormContext();\n  var saveContext = useSaveContext();\n\n  var _g = useFormState(),\n      dirtyFields = _g.dirtyFields,\n      isValidating = _g.isValidating,\n      isSubmitting = _g.isSubmitting; // useFormState().isDirty might differ from useFormState().dirtyFields (https://github.com/react-hook-form/react-hook-form/issues/4740)\n\n\n  var isDirty = Object.keys(dirtyFields).length > 0; // Use form isDirty, isValidating and form context saving to enable or disable the save button\n  // if alwaysEnable is undefined\n\n  var disabled = valueOrDefault(alwaysEnable === false || alwaysEnable === undefined ? undefined : !alwaysEnable, disabledProp || !isDirty || isValidating || isSubmitting);\n  warning(type === 'submit' && (mutationOptions && (mutationOptions.onSuccess || mutationOptions.onError) || transform), 'Cannot use <SaveButton mutationOptions> props on a button of type \"submit\". To override the default mutation options on a particular save button, set the <SaveButton type=\"button\"> prop, or set mutationOptions in the main view component (<Create> or <Edit>).');\n  var handleSubmit = useCallback(function (values) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var errors;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(saveContext === null || saveContext === void 0 ? void 0 : saveContext.save)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , saveContext.save(values, __assign(__assign({}, mutationOptions), {\n              transform: transform\n            }))];\n\n          case 1:\n            errors = _a.sent();\n            _a.label = 2;\n\n          case 2:\n            if (errors != null) {\n              setSubmissionErrors(errors, form.setError);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, [form.setError, saveContext, mutationOptions, transform]);\n  var handleClick = useCallback(function (event) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (onClick) {\n              onClick(event);\n            }\n\n            if (event.defaultPrevented) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            if (!(type === 'button')) return [3\n            /*break*/\n            , 2]; // this button doesn't submit the form, so it doesn't trigger useIsFormInvalid in <FormContent>\n            // therefore we need to check for errors manually\n\n            event.stopPropagation();\n            return [4\n            /*yield*/\n            , form.handleSubmit(handleSubmit)(event)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, [onClick, type, form, handleSubmit]);\n  var displayedLabel = label && translate(label, {\n    _: label\n  });\n  return React.createElement(StyledButton, __assign({\n    variant: variant,\n    type: type,\n    color: color,\n    \"aria-label\": displayedLabel,\n    disabled: disabled,\n    onClick: handleClick\n  }, rest), isSubmitting ? React.createElement(CircularProgress, {\n    sx: circularProgressStyle,\n    size: 14,\n    thickness: 3,\n    color: \"inherit\"\n  }) : icon, displayedLabel);\n};\nvar circularProgressStyle = {\n  '&.MuiCircularProgress-root': {\n    marginRight: '10px',\n    marginLeft: '2px'\n  }\n};\nvar defaultIcon = React.createElement(ContentSave, null);\nSaveButton.propTypes = {\n  className: PropTypes.string,\n  invalid: PropTypes.bool,\n  label: PropTypes.string,\n  variant: PropTypes.oneOf(['text', 'outlined', 'contained']),\n  icon: PropTypes.element,\n  alwaysEnable: PropTypes.bool\n};\nvar PREFIX = 'RaSaveButton';\nvar StyledButton = styled(Button, {\n  name: PREFIX,\n  overridesResolver: function (props, styles) {\n    return styles.root;\n  }\n})(function (_a) {\n  var _b;\n\n  var theme = _a.theme;\n  return _b = {\n    position: 'relative'\n  }, _b[\"& .MuiSvgIcon-root, & .MuiIcon-root, & .MuiCircularProgress-root\"] = {\n    marginRight: theme.spacing(1)\n  }, _b[\"& .MuiSvgIcon-root, & .MuiIcon-root\"] = {\n    fontSize: 18\n  }, _b;\n});\n\nvar valueOrDefault = function (value, defaultValue) {\n  return typeof value === 'undefined' ? defaultValue : value;\n};","map":{"version":3,"mappings":"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","names":["React","useCallback","styled","PropTypes","Button","CircularProgress","ContentSave","useFormContext","useFormState","useSaveContext","useTranslate","warning","setSubmissionErrors","SaveButton","props","_a","_b","icon","defaultIcon","invalid","_c","label","onClick","mutationOptions","disabledProp","_d","type","transform","_e","variant","_f","alwaysEnable","rest","translate","form","saveContext","dirtyFields","isValidating","isSubmitting","isDirty","Object","keys","length","disabled","valueOrDefault","undefined","onSuccess","onError","handleSubmit","values","save","__assign","errors","setError","handleClick","event","defaultPrevented","stopPropagation","displayedLabel","_","StyledButton","color","sx","circularProgressStyle","size","thickness","marginRight","marginLeft","propTypes","className","string","bool","oneOf","element","PREFIX","name","overridesResolver","styles","root","theme","position","spacing","fontSize","value","defaultValue"],"sources":["/var/www/a1boots/node_modules/ra-ui-materialui/src/button/SaveButton.tsx"],"sourcesContent":["import * as React from 'react';\nimport { MouseEventHandler, ReactElement, useCallback } from 'react';\nimport { UseMutationOptions } from 'react-query';\nimport { styled } from '@mui/material/styles';\nimport PropTypes from 'prop-types';\nimport { Button, ButtonProps, CircularProgress } from '@mui/material';\nimport ContentSave from '@mui/icons-material/Save';\nimport { useFormContext, useFormState } from 'react-hook-form';\nimport {\n    CreateParams,\n    RaRecord,\n    TransformData,\n    UpdateParams,\n    useSaveContext,\n    useTranslate,\n    warning,\n    setSubmissionErrors,\n} from 'ra-core';\n\n/**\n * Submit button for resource forms (Edit and Create).\n *\n * @typedef {Object} Props the props you can use (other props are injected by the <Toolbar>)\n * @prop {string} className\n * @prop {string} label Button label. Defaults to 'ra.action.save', translated.\n * @prop {boolean} disabled Disable the button.\n * @prop {string} variant Material UI variant for the button. Defaults to 'contained'.\n * @prop {ReactElement} icon\n * @prop {function} mutationOptions Object of options passed to react-query.\n * @prop {function} transform Callback to execute before calling the dataProvider. Receives the data from the form, must return that transformed data. Can be asynchronous (and return a Promise)\n * @prop {boolean} alwaysEnable Force enabling the <SaveButton>. If it's not defined, the `<SaveButton>` will be enabled using `react-hook-form`'s `isValidating` state props and form context's `saving` prop (disabled if isValidating or saving, enabled otherwise).\n *\n * @param {Props} props\n *\n * @example // with custom success side effect\n *\n * const MySaveButton = props => {\n *     const notify = useNotify();\n *     const redirect = useRedirect();\n *     const onSuccess = (response) => {\n *         notify(`Post \"${response.data.title}\" saved!`);\n *         redirect('/posts');\n *     };\n *     return <SaveButton {...props} mutationOptions={{ onSuccess }} />;\n * }\n */\nexport const SaveButton = <RecordType extends RaRecord = any>(\n    props: SaveButtonProps<RecordType>\n) => {\n    const {\n        color = 'primary',\n        icon = defaultIcon,\n        invalid,\n        label = 'ra.action.save',\n        onClick,\n        mutationOptions,\n        disabled: disabledProp,\n        type = 'submit',\n        transform,\n        variant = 'contained',\n        alwaysEnable = false,\n        ...rest\n    } = props;\n    const translate = useTranslate();\n    const form = useFormContext();\n    const saveContext = useSaveContext();\n    const { dirtyFields, isValidating, isSubmitting } = useFormState();\n    // useFormState().isDirty might differ from useFormState().dirtyFields (https://github.com/react-hook-form/react-hook-form/issues/4740)\n    const isDirty = Object.keys(dirtyFields).length > 0;\n    // Use form isDirty, isValidating and form context saving to enable or disable the save button\n    // if alwaysEnable is undefined\n    const disabled = valueOrDefault(\n        alwaysEnable === false || alwaysEnable === undefined\n            ? undefined\n            : !alwaysEnable,\n        disabledProp || !isDirty || isValidating || isSubmitting\n    );\n\n    warning(\n        type === 'submit' &&\n            ((mutationOptions &&\n                (mutationOptions.onSuccess || mutationOptions.onError)) ||\n                transform),\n        'Cannot use <SaveButton mutationOptions> props on a button of type \"submit\". To override the default mutation options on a particular save button, set the <SaveButton type=\"button\"> prop, or set mutationOptions in the main view component (<Create> or <Edit>).'\n    );\n\n    const handleSubmit = useCallback(\n        async values => {\n            let errors;\n            if (saveContext?.save) {\n                errors = await saveContext.save(values, {\n                    ...mutationOptions,\n                    transform,\n                });\n            }\n            if (errors != null) {\n                setSubmissionErrors(errors, form.setError);\n            }\n        },\n        [form.setError, saveContext, mutationOptions, transform]\n    );\n\n    const handleClick: MouseEventHandler<HTMLButtonElement> = useCallback(\n        async event => {\n            if (onClick) {\n                onClick(event);\n            }\n            if (event.defaultPrevented) {\n                return;\n            }\n            if (type === 'button') {\n                // this button doesn't submit the form, so it doesn't trigger useIsFormInvalid in <FormContent>\n                // therefore we need to check for errors manually\n                event.stopPropagation();\n                await form.handleSubmit(handleSubmit)(event);\n            }\n        },\n        [onClick, type, form, handleSubmit]\n    );\n\n    const displayedLabel = label && translate(label, { _: label });\n\n    return (\n        <StyledButton\n            variant={variant}\n            type={type}\n            color={color}\n            aria-label={displayedLabel}\n            disabled={disabled}\n            onClick={handleClick}\n            {...rest}\n        >\n            {isSubmitting ? (\n                <CircularProgress\n                    sx={circularProgressStyle}\n                    size={14}\n                    thickness={3}\n                    color=\"inherit\"\n                />\n            ) : (\n                icon\n            )}\n            {displayedLabel}\n        </StyledButton>\n    );\n};\n\nconst circularProgressStyle = {\n    '&.MuiCircularProgress-root': {\n        marginRight: '10px',\n        marginLeft: '2px',\n    },\n};\n\nconst defaultIcon = <ContentSave />;\n\ninterface Props<\n    RecordType extends RaRecord = any,\n    MutationOptionsError = unknown\n> {\n    className?: string;\n    disabled?: boolean;\n    icon?: ReactElement;\n    invalid?: boolean;\n    label?: string;\n    mutationOptions?: UseMutationOptions<\n        RecordType,\n        MutationOptionsError,\n        CreateParams<RecordType> | UpdateParams<RecordType>\n    >;\n    transform?: TransformData;\n    variant?: string;\n}\n\nexport type SaveButtonProps<RecordType extends RaRecord = any> = Props<\n    RecordType\n> &\n    ButtonProps & {\n        alwaysEnable?: boolean;\n    };\n\nSaveButton.propTypes = {\n    className: PropTypes.string,\n    invalid: PropTypes.bool,\n    label: PropTypes.string,\n    variant: PropTypes.oneOf(['text', 'outlined', 'contained']),\n    icon: PropTypes.element,\n    alwaysEnable: PropTypes.bool,\n};\n\nconst PREFIX = 'RaSaveButton';\n\nconst StyledButton = styled(Button, {\n    name: PREFIX,\n    overridesResolver: (props, styles) => styles.root,\n})(({ theme }) => ({\n    position: 'relative',\n    [`& .MuiSvgIcon-root, & .MuiIcon-root, & .MuiCircularProgress-root`]: {\n        marginRight: theme.spacing(1),\n    },\n    [`& .MuiSvgIcon-root, & .MuiIcon-root`]: {\n        fontSize: 18,\n    },\n}));\n\nconst valueOrDefault = (value, defaultValue) =>\n    typeof value === 'undefined' ? defaultValue : value;\n"]},"metadata":{},"sourceType":"module"}