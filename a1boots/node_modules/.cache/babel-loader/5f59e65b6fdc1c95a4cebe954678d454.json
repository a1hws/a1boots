{"ast":null,"code":"var isMatchingReferencesError = function isMatchingReferencesError(matchingReferences) {\n  return matchingReferences && matchingReferences.error !== undefined;\n};\n\nexport var getStatusForInput = function getStatusForInput(_a) {\n  var field = _a.field,\n      matchingReferences = _a.matchingReferences,\n      referenceRecord = _a.referenceRecord,\n      _b = _a.translate,\n      translate = _b === void 0 ? function (x) {\n    return x;\n  } : _b;\n  var matchingReferencesError = isMatchingReferencesError(matchingReferences) ? translate(matchingReferences.error, {\n    _: matchingReferences.error\n  }) : null;\n  var selectedReferenceError = field.value && !referenceRecord ? translate('ra.input.references.single_missing', {\n    _: 'ra.input.references.single_missing'\n  }) : null;\n  return {\n    waiting: field.value && selectedReferenceError && !matchingReferences || !field.value && !matchingReferences,\n    error: field.value && selectedReferenceError && matchingReferencesError || !field.value && matchingReferencesError ? field.value ? selectedReferenceError : matchingReferencesError : null,\n    warning: selectedReferenceError || matchingReferencesError,\n    choices: Array.isArray(matchingReferences) ? matchingReferences : [referenceRecord].filter(function (choice) {\n      return choice;\n    })\n  };\n};\nexport var REFERENCES_STATUS_READY = 'REFERENCES_STATUS_READY';\nexport var REFERENCES_STATUS_INCOMPLETE = 'REFERENCES_STATUS_INCOMPLETE';\nexport var REFERENCES_STATUS_EMPTY = 'REFERENCES_STATUS_EMPTY';\nexport var getSelectedReferencesStatus = function getSelectedReferencesStatus(field, referenceRecords) {\n  return !field.value || field.value.length === referenceRecords.length ? REFERENCES_STATUS_READY : referenceRecords.length > 0 ? REFERENCES_STATUS_INCOMPLETE : REFERENCES_STATUS_EMPTY;\n};\nexport var getStatusForArrayInput = function getStatusForArrayInput(_a) {\n  var field = _a.field,\n      matchingReferences = _a.matchingReferences,\n      referenceRecords = _a.referenceRecords,\n      _b = _a.translate,\n      translate = _b === void 0 ? function (x) {\n    return x;\n  } : _b; // selectedReferencesDataStatus can be \"empty\" (no data was found for references from input.value)\n  // or \"incomplete\" (Not all of the reference data was found)\n  // or \"ready\" (all references data was found or there is no references from input.value)\n\n  var selectedReferencesDataStatus = getSelectedReferencesStatus(field, referenceRecords);\n  var matchingReferencesError = isMatchingReferencesError(matchingReferences) ? translate(matchingReferences.error, {\n    _: matchingReferences.error\n  }) : null;\n  var choices = Array.isArray(matchingReferences) ? referenceRecords.concat(matchingReferences.filter(function (choice) {\n    return referenceRecords.findIndex(function (c) {\n      return c.id === choice.id;\n    }) === -1;\n  })) : referenceRecords;\n  return {\n    waiting: !matchingReferences && field.value && selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY || !matchingReferences && !field.value,\n    error: matchingReferencesError && (!field.value || field.value && selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY) ? translate('ra.input.references.all_missing', {\n      _: 'ra.input.references.all_missing'\n    }) : null,\n    warning: matchingReferencesError || field.value && selectedReferencesDataStatus !== REFERENCES_STATUS_READY ? matchingReferencesError || translate('ra.input.references.many_missing', {\n      _: 'ra.input.references.many_missing'\n    }) : null,\n    choices: choices\n  };\n};","map":{"version":3,"mappings":"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","names":["isMatchingReferencesError","matchingReferences","error","undefined","getStatusForInput","_a","field","referenceRecord","_b","translate","matchingReferencesError","_","selectedReferenceError","value","waiting","warning","choices","Array","isArray","filter","REFERENCES_STATUS_READY","REFERENCES_STATUS_INCOMPLETE","REFERENCES_STATUS_EMPTY","getSelectedReferencesStatus","referenceRecords","length","getStatusForArrayInput","selectedReferencesDataStatus","concat","findIndex","id","choice"],"sources":["/var/www/a1boots/node_modules/ra-core/src/controller/input/referenceDataStatus.ts"],"sourcesContent":["import { RaRecord, Translate } from '../../types';\nimport { MatchingReferencesError } from './types';\nimport { ControllerRenderProps } from 'react-hook-form';\n\ninterface GetStatusForInputParams<RecordType extends RaRecord = RaRecord> {\n    field: Pick<ControllerRenderProps, 'value'>;\n    matchingReferences: RecordType[] | MatchingReferencesError;\n    referenceRecord: RecordType;\n    translate: Translate;\n}\n\nconst isMatchingReferencesError = (\n    matchingReferences?: any\n): matchingReferences is MatchingReferencesError =>\n    matchingReferences && matchingReferences.error !== undefined;\n\nexport const getStatusForInput = <RecordType extends RaRecord = RaRecord>({\n    field,\n    matchingReferences,\n    referenceRecord,\n    translate = x => x,\n}: GetStatusForInputParams<RecordType>) => {\n    const matchingReferencesError = isMatchingReferencesError(\n        matchingReferences\n    )\n        ? translate(matchingReferences.error, {\n              _: matchingReferences.error,\n          })\n        : null;\n    const selectedReferenceError =\n        field.value && !referenceRecord\n            ? translate('ra.input.references.single_missing', {\n                  _: 'ra.input.references.single_missing',\n              })\n            : null;\n\n    return {\n        waiting:\n            (field.value && selectedReferenceError && !matchingReferences) ||\n            (!field.value && !matchingReferences),\n        error:\n            (field.value &&\n                selectedReferenceError &&\n                matchingReferencesError) ||\n            (!field.value && matchingReferencesError)\n                ? field.value\n                    ? selectedReferenceError\n                    : matchingReferencesError\n                : null,\n        warning: selectedReferenceError || matchingReferencesError,\n        choices: Array.isArray(matchingReferences)\n            ? matchingReferences\n            : [referenceRecord].filter(choice => choice),\n    };\n};\n\nexport const REFERENCES_STATUS_READY = 'REFERENCES_STATUS_READY';\nexport const REFERENCES_STATUS_INCOMPLETE = 'REFERENCES_STATUS_INCOMPLETE';\nexport const REFERENCES_STATUS_EMPTY = 'REFERENCES_STATUS_EMPTY';\n\nexport const getSelectedReferencesStatus = <RecordType extends RaRecord = any>(\n    field: Pick<ControllerRenderProps, 'value'>,\n    referenceRecords: RecordType[]\n) =>\n    !field.value || field.value.length === referenceRecords.length\n        ? REFERENCES_STATUS_READY\n        : referenceRecords.length > 0\n        ? REFERENCES_STATUS_INCOMPLETE\n        : REFERENCES_STATUS_EMPTY;\n\ninterface GetStatusForArrayInputParams<RecordType extends RaRecord = any> {\n    field: ControllerRenderProps;\n    matchingReferences: RecordType[] | MatchingReferencesError;\n    referenceRecords: RecordType[];\n    translate: Translate;\n}\n\nexport const getStatusForArrayInput = <RecordType extends RaRecord = any>({\n    field,\n    matchingReferences,\n    referenceRecords,\n    translate = x => x,\n}: GetStatusForArrayInputParams<RecordType>) => {\n    // selectedReferencesDataStatus can be \"empty\" (no data was found for references from input.value)\n    // or \"incomplete\" (Not all of the reference data was found)\n    // or \"ready\" (all references data was found or there is no references from input.value)\n    const selectedReferencesDataStatus = getSelectedReferencesStatus(\n        field,\n        referenceRecords\n    );\n\n    const matchingReferencesError = isMatchingReferencesError(\n        matchingReferences\n    )\n        ? translate(matchingReferences.error, {\n              _: matchingReferences.error,\n          })\n        : null;\n\n    const choices = Array.isArray(matchingReferences)\n        ? referenceRecords.concat(\n              matchingReferences.filter(\n                  choice =>\n                      referenceRecords.findIndex(c => c.id === choice.id) === -1\n              )\n          )\n        : referenceRecords;\n\n    return {\n        waiting:\n            (!matchingReferences &&\n                field.value &&\n                selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY) ||\n            (!matchingReferences && !field.value),\n        error:\n            matchingReferencesError &&\n            (!field.value ||\n                (field.value &&\n                    selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY))\n                ? translate('ra.input.references.all_missing', {\n                      _: 'ra.input.references.all_missing',\n                  })\n                : null,\n        warning:\n            matchingReferencesError ||\n            (field.value &&\n                selectedReferencesDataStatus !== REFERENCES_STATUS_READY)\n                ? matchingReferencesError ||\n                  translate('ra.input.references.many_missing', {\n                      _: 'ra.input.references.many_missing',\n                  })\n                : null,\n        choices,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}