{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport * as React from 'react';\nimport { styled } from '@mui/material/styles';\nimport clsx from 'clsx';\nimport { useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport get from 'lodash/get';\nimport FormLabel from '@mui/material/FormLabel';\nimport FormControl from '@mui/material/FormControl';\nimport FormGroup from '@mui/material/FormGroup';\nimport FormHelperText from '@mui/material/FormHelperText';\nimport { FieldTitle, useInput, useChoicesContext } from 'ra-core';\nimport { sanitizeInputRestProps } from './sanitizeInputRestProps';\nimport { CheckboxGroupInputItem } from './CheckboxGroupInputItem';\nimport { InputHelperText } from './InputHelperText';\nimport { Labeled } from '../Labeled';\nimport { LinearProgress } from '../layout';\n/**\n * An Input component for a checkbox group, using an array of objects for the options\n *\n * Pass possible options as an array of objects in the 'choices' attribute.\n *\n * The expected input must be an array of identifiers (e.g. [12, 31]) which correspond to\n * the 'optionValue' of 'choices' attribute objects.\n *\n * By default, the options are built from:\n *  - the 'id' property as the option value,\n *  - the 'name' property as the option text\n * @example\n * const choices = [\n *     { id: 12, name: 'Ray Hakt' },\n *     { id: 31, name: 'Ann Gullar' },\n *     { id: 42, name: 'Sean Phonee' },\n * ];\n * <CheckboxGroupInput source=\"recipients\" choices={choices} />\n *\n * You can also customize the properties to use for the option name and value,\n * thanks to the 'optionText' and 'optionValue' attributes.\n * @example\n * const choices = [\n *    { _id: 123, full_name: 'Leo Tolstoi' },\n *    { _id: 456, full_name: 'Jane Austen' },\n * ];\n * <CheckboxGroupInput source=\"recipients\" choices={choices} optionText=\"full_name\" optionValue=\"_id\" />\n *\n * `optionText` also accepts a function, so you can shape the option text at will:\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;\n * <CheckboxGroupInput source=\"recipients\" choices={choices} optionText={optionRenderer} />\n *\n * `optionText` also accepts a React Element, that can access\n * the related choice through the `useRecordContext` hook. You can use Field components there.\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const FullNameField = () => {\n *     const record = useRecordContext();\n *     return <span>{record.first_name} {record.last_name}</span>;\n * };\n *\n * <CheckboxGroupInput source=\"recipients\" choices={choices} optionText={<FullNameField />}/>\n *\n * The choices are translated by default, so you can use translation identifiers as choices:\n * @example\n * const choices = [\n *    { id: 'programming', name: 'myroot.category.programming' },\n *    { id: 'lifestyle', name: 'myroot.category.lifestyle' },\n *    { id: 'photography', name: 'myroot.category.photography' },\n * ];\n *\n * However, in some cases (e.g. inside a `<ReferenceArrayInput>`), you may not want\n * the choice to be translated. In that case, set the `translateChoice` prop to false.\n * @example\n * <CheckboxGroupInput source=\"tags\" choices={choices} translateChoice={false}/>\n *\n * The object passed as `options` props is passed to the Material UI <Checkbox> components\n */\n\nexport var CheckboxGroupInput = function CheckboxGroupInput(props) {\n  var choicesProp = props.choices,\n      className = props.className,\n      classesOverride = props.classes,\n      format = props.format,\n      helperText = props.helperText,\n      label = props.label,\n      labelPlacement = props.labelPlacement,\n      isLoadingProp = props.isLoading,\n      isFetchingProp = props.isFetching,\n      _a = props.margin,\n      margin = _a === void 0 ? 'dense' : _a,\n      onBlur = props.onBlur,\n      onChange = props.onChange,\n      options = props.options,\n      _b = props.optionText,\n      optionText = _b === void 0 ? 'name' : _b,\n      _c = props.optionValue,\n      optionValue = _c === void 0 ? 'id' : _c,\n      parse = props.parse,\n      resourceProp = props.resource,\n      _d = props.row,\n      row = _d === void 0 ? true : _d,\n      sourceProp = props.source,\n      _e = props.translateChoice,\n      translateChoice = _e === void 0 ? true : _e,\n      validate = props.validate,\n      rest = __rest(props, [\"choices\", \"className\", \"classes\", \"format\", \"helperText\", \"label\", \"labelPlacement\", \"isLoading\", \"isFetching\", \"margin\", \"onBlur\", \"onChange\", \"options\", \"optionText\", \"optionValue\", \"parse\", \"resource\", \"row\", \"source\", \"translateChoice\", \"validate\"]);\n\n  var _f = useChoicesContext({\n    choices: choicesProp,\n    isFetching: isFetchingProp,\n    isLoading: isLoadingProp,\n    resource: resourceProp,\n    source: sourceProp\n  }),\n      allChoices = _f.allChoices,\n      isLoading = _f.isLoading,\n      fetchError = _f.error,\n      resource = _f.resource,\n      source = _f.source;\n\n  if (source === undefined) {\n    throw new Error(\"If you're not wrapping the CheckboxGroupInput inside a ReferenceArrayInput, you must provide the source prop\");\n  }\n\n  if (!isLoading && !fetchError && allChoices === undefined) {\n    throw new Error(\"If you're not wrapping the CheckboxGroupInput inside a ReferenceArrayInput, you must provide the choices prop\");\n  }\n\n  var _g = useInput(__assign({\n    format: format,\n    parse: parse,\n    resource: resource,\n    source: source,\n    validate: validate,\n    onChange: onChange,\n    onBlur: onBlur\n  }, rest)),\n      _h = _g.field,\n      formOnChange = _h.onChange,\n      formOnBlur = _h.onBlur,\n      value = _h.value,\n      _j = _g.fieldState,\n      error = _j.error,\n      invalid = _j.invalid,\n      isTouched = _j.isTouched,\n      isSubmitted = _g.formState.isSubmitted,\n      id = _g.id,\n      isRequired = _g.isRequired;\n\n  var handleCheck = useCallback(function (event, isChecked) {\n    var newValue;\n\n    if (allChoices.every(function (item) {\n      return typeof get(item, optionValue) === 'number';\n    })) {\n      try {\n        // try to convert string value to number, e.g. '123'\n        newValue = JSON.parse(event.target.value);\n      } catch (e) {\n        // impossible to convert value, e.g. 'abc'\n        newValue = event.target.value;\n      }\n    } else {\n      newValue = event.target.value;\n    }\n\n    if (isChecked) {\n      formOnChange(__spreadArray(__spreadArray([], value || [], true), [newValue], false));\n    } else {\n      formOnChange(value.filter(function (v) {\n        return v != newValue;\n      })); // eslint-disable-line eqeqeq\n    }\n\n    formOnBlur(); // Ensure field is flagged as touched\n  }, [allChoices, formOnChange, formOnBlur, optionValue, value]);\n\n  if (isLoading && (!allChoices || allChoices.length === 0)) {\n    return React.createElement(Labeled, __assign({\n      id: id,\n      label: label,\n      source: source,\n      resource: resource,\n      className: clsx('ra-input', \"ra-input-\".concat(source), className),\n      isRequired: isRequired\n    }, rest), React.createElement(LinearProgress, null));\n  }\n\n  return React.createElement(StyledFormControl, __assign({\n    component: \"fieldset\",\n    margin: margin,\n    error: fetchError || (isTouched || isSubmitted) && invalid,\n    className: clsx('ra-input', \"ra-input-\".concat(source), className)\n  }, sanitizeRestProps(rest)), React.createElement(FormLabel, {\n    component: \"legend\",\n    className: CheckboxGroupInputClasses.label\n  }, React.createElement(FieldTitle, {\n    label: label,\n    source: source,\n    resource: resource,\n    isRequired: isRequired\n  })), React.createElement(FormGroup, {\n    row: row\n  }, allChoices === null || allChoices === void 0 ? void 0 : allChoices.map(function (choice) {\n    return React.createElement(CheckboxGroupInputItem, __assign({\n      key: get(choice, optionValue),\n      choice: choice,\n      id: id,\n      onChange: handleCheck,\n      options: options,\n      optionText: optionText,\n      optionValue: optionValue,\n      translateChoice: translateChoice,\n      value: value,\n      labelPlacement: labelPlacement\n    }, sanitizeRestProps(rest)));\n  })), React.createElement(FormHelperText, {\n    error: fetchError || (isTouched || isSubmitted) && !!error,\n    className: CheckboxGroupInputClasses.helperText\n  }, React.createElement(InputHelperText, {\n    touched: isTouched || isSubmitted || fetchError,\n    error: (error === null || error === void 0 ? void 0 : error.message) || (fetchError === null || fetchError === void 0 ? void 0 : fetchError.message),\n    helperText: helperText\n  })));\n};\n\nvar sanitizeRestProps = function sanitizeRestProps(_a) {\n  var refetch = _a.refetch,\n      setFilter = _a.setFilter,\n      setPagination = _a.setPagination,\n      setSort = _a.setSort,\n      loaded = _a.loaded,\n      touched = _a.touched,\n      rest = __rest(_a, [\"refetch\", \"setFilter\", \"setPagination\", \"setSort\", \"loaded\", \"touched\"]);\n\n  return sanitizeInputRestProps(rest);\n};\n\nCheckboxGroupInput.propTypes = {\n  choices: PropTypes.arrayOf(PropTypes.any),\n  className: PropTypes.string,\n  source: PropTypes.string,\n  optionText: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.element]),\n  optionValue: PropTypes.string,\n  row: PropTypes.bool,\n  resource: PropTypes.string,\n  translateChoice: PropTypes.bool\n};\nvar PREFIX = 'RaCheckboxGroupInput';\nexport var CheckboxGroupInputClasses = {\n  label: \"\".concat(PREFIX, \"-label\"),\n  helperText: \"\".concat(PREFIX, \"-helperText\")\n};\nvar StyledFormControl = styled(FormControl, {\n  name: PREFIX,\n  overridesResolver: function overridesResolver(props, styles) {\n    return styles.root;\n  }\n})(function (_a) {\n  var _b;\n\n  var theme = _a.theme;\n  return _b = {}, _b[\"& .\".concat(CheckboxGroupInputClasses.label)] = {\n    transform: 'translate(0, 4px) scale(0.75)',\n    transformOrigin: \"top \".concat(theme.direction === 'ltr' ? 'left' : 'right')\n  }, _b[\"& .\".concat(CheckboxGroupInputClasses.helperText)] = {\n    marginLeft: 0,\n    marginRight: 0\n  }, _b;\n});","map":{"version":3,"mappings":"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","names":["React","styled","clsx","useCallback","PropTypes","get","FormLabel","FormControl","FormGroup","FormHelperText","FieldTitle","useInput","useChoicesContext","sanitizeInputRestProps","CheckboxGroupInputItem","InputHelperText","Labeled","LinearProgress","CheckboxGroupInput","choicesProp","props","className","classesOverride","format","helperText","label","labelPlacement","isLoadingProp","isFetchingProp","_a","margin","onBlur","onChange","options","_b","optionText","_c","optionValue","parse","resourceProp","_d","row","sourceProp","_e","translateChoice","validate","rest","choices","isFetching","isLoading","resource","source","allChoices","fetchError","undefined","Error","_h","formOnChange","formOnBlur","value","_j","error","invalid","isTouched","isSubmitted","id","isRequired","handleCheck","event","isChecked","newValue","every","item","JSON","target","e","filter","length","__assign","StyledFormControl","component","sanitizeRestProps","CheckboxGroupInputClasses","map","key","choice","touched","message","setFilter","setPagination","setSort","loaded","propTypes","arrayOf","any","string","oneOfType","func","element","bool","PREFIX","name","overridesResolver","styles","root","theme","transform","transformOrigin","direction","marginLeft","marginRight"],"sources":["/var/www/a1boots/node_modules/ra-ui-materialui/src/input/CheckboxGroupInput.tsx"],"sourcesContent":["import * as React from 'react';\nimport { styled } from '@mui/material/styles';\nimport clsx from 'clsx';\nimport { useCallback, FunctionComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport get from 'lodash/get';\nimport FormLabel from '@mui/material/FormLabel';\nimport FormControl, { FormControlProps } from '@mui/material/FormControl';\nimport FormGroup from '@mui/material/FormGroup';\nimport FormHelperText from '@mui/material/FormHelperText';\nimport { CheckboxProps } from '@mui/material/Checkbox';\nimport { FieldTitle, useInput, ChoicesProps, useChoicesContext } from 'ra-core';\n\nimport { CommonInputProps } from './CommonInputProps';\nimport { sanitizeInputRestProps } from './sanitizeInputRestProps';\nimport { CheckboxGroupInputItem } from './CheckboxGroupInputItem';\nimport { InputHelperText } from './InputHelperText';\nimport { Labeled } from '../Labeled';\nimport { LinearProgress } from '../layout';\n\n/**\n * An Input component for a checkbox group, using an array of objects for the options\n *\n * Pass possible options as an array of objects in the 'choices' attribute.\n *\n * The expected input must be an array of identifiers (e.g. [12, 31]) which correspond to\n * the 'optionValue' of 'choices' attribute objects.\n *\n * By default, the options are built from:\n *  - the 'id' property as the option value,\n *  - the 'name' property as the option text\n * @example\n * const choices = [\n *     { id: 12, name: 'Ray Hakt' },\n *     { id: 31, name: 'Ann Gullar' },\n *     { id: 42, name: 'Sean Phonee' },\n * ];\n * <CheckboxGroupInput source=\"recipients\" choices={choices} />\n *\n * You can also customize the properties to use for the option name and value,\n * thanks to the 'optionText' and 'optionValue' attributes.\n * @example\n * const choices = [\n *    { _id: 123, full_name: 'Leo Tolstoi' },\n *    { _id: 456, full_name: 'Jane Austen' },\n * ];\n * <CheckboxGroupInput source=\"recipients\" choices={choices} optionText=\"full_name\" optionValue=\"_id\" />\n *\n * `optionText` also accepts a function, so you can shape the option text at will:\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;\n * <CheckboxGroupInput source=\"recipients\" choices={choices} optionText={optionRenderer} />\n *\n * `optionText` also accepts a React Element, that can access\n * the related choice through the `useRecordContext` hook. You can use Field components there.\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const FullNameField = () => {\n *     const record = useRecordContext();\n *     return <span>{record.first_name} {record.last_name}</span>;\n * };\n *\n * <CheckboxGroupInput source=\"recipients\" choices={choices} optionText={<FullNameField />}/>\n *\n * The choices are translated by default, so you can use translation identifiers as choices:\n * @example\n * const choices = [\n *    { id: 'programming', name: 'myroot.category.programming' },\n *    { id: 'lifestyle', name: 'myroot.category.lifestyle' },\n *    { id: 'photography', name: 'myroot.category.photography' },\n * ];\n *\n * However, in some cases (e.g. inside a `<ReferenceArrayInput>`), you may not want\n * the choice to be translated. In that case, set the `translateChoice` prop to false.\n * @example\n * <CheckboxGroupInput source=\"tags\" choices={choices} translateChoice={false}/>\n *\n * The object passed as `options` props is passed to the Material UI <Checkbox> components\n */\nexport const CheckboxGroupInput: FunctionComponent<CheckboxGroupInputProps> = props => {\n    const {\n        choices: choicesProp,\n        className,\n        classes: classesOverride,\n        format,\n        helperText,\n        label,\n        labelPlacement,\n        isLoading: isLoadingProp,\n        isFetching: isFetchingProp,\n        margin = 'dense',\n        onBlur,\n        onChange,\n        options,\n        optionText = 'name',\n        optionValue = 'id',\n        parse,\n        resource: resourceProp,\n        row = true,\n        source: sourceProp,\n        translateChoice = true,\n        validate,\n        ...rest\n    } = props;\n\n    const {\n        allChoices,\n        isLoading,\n        error: fetchError,\n        resource,\n        source,\n    } = useChoicesContext({\n        choices: choicesProp,\n        isFetching: isFetchingProp,\n        isLoading: isLoadingProp,\n        resource: resourceProp,\n        source: sourceProp,\n    });\n\n    if (source === undefined) {\n        throw new Error(\n            `If you're not wrapping the CheckboxGroupInput inside a ReferenceArrayInput, you must provide the source prop`\n        );\n    }\n\n    if (!isLoading && !fetchError && allChoices === undefined) {\n        throw new Error(\n            `If you're not wrapping the CheckboxGroupInput inside a ReferenceArrayInput, you must provide the choices prop`\n        );\n    }\n\n    const {\n        field: { onChange: formOnChange, onBlur: formOnBlur, value },\n        fieldState: { error, invalid, isTouched },\n        formState: { isSubmitted },\n        id,\n        isRequired,\n    } = useInput({\n        format,\n        parse,\n        resource,\n        source,\n        validate,\n        onChange,\n        onBlur,\n        ...rest,\n    });\n\n    const handleCheck = useCallback(\n        (event, isChecked) => {\n            let newValue;\n\n            if (\n                allChoices.every(\n                    item => typeof get(item, optionValue) === 'number'\n                )\n            ) {\n                try {\n                    // try to convert string value to number, e.g. '123'\n                    newValue = JSON.parse(event.target.value);\n                } catch (e) {\n                    // impossible to convert value, e.g. 'abc'\n                    newValue = event.target.value;\n                }\n            } else {\n                newValue = event.target.value;\n            }\n\n            if (isChecked) {\n                formOnChange([...(value || []), ...[newValue]]);\n            } else {\n                formOnChange(value.filter(v => v != newValue)); // eslint-disable-line eqeqeq\n            }\n            formOnBlur(); // Ensure field is flagged as touched\n        },\n        [allChoices, formOnChange, formOnBlur, optionValue, value]\n    );\n\n    if (isLoading && (!allChoices || allChoices.length === 0)) {\n        return (\n            <Labeled\n                id={id}\n                label={label}\n                source={source}\n                resource={resource}\n                className={clsx('ra-input', `ra-input-${source}`, className)}\n                isRequired={isRequired}\n                {...rest}\n            >\n                <LinearProgress />\n            </Labeled>\n        );\n    }\n\n    return (\n        <StyledFormControl\n            component=\"fieldset\"\n            margin={margin}\n            error={fetchError || ((isTouched || isSubmitted) && invalid)}\n            className={clsx('ra-input', `ra-input-${source}`, className)}\n            {...sanitizeRestProps(rest)}\n        >\n            <FormLabel\n                component=\"legend\"\n                className={CheckboxGroupInputClasses.label}\n            >\n                <FieldTitle\n                    label={label}\n                    source={source}\n                    resource={resource}\n                    isRequired={isRequired}\n                />\n            </FormLabel>\n            <FormGroup row={row}>\n                {allChoices?.map(choice => (\n                    <CheckboxGroupInputItem\n                        key={get(choice, optionValue)}\n                        choice={choice}\n                        id={id}\n                        onChange={handleCheck}\n                        options={options}\n                        optionText={optionText}\n                        optionValue={optionValue}\n                        translateChoice={translateChoice}\n                        value={value}\n                        labelPlacement={labelPlacement}\n                        {...sanitizeRestProps(rest)}\n                    />\n                ))}\n            </FormGroup>\n            <FormHelperText\n                error={fetchError || ((isTouched || isSubmitted) && !!error)}\n                className={CheckboxGroupInputClasses.helperText}\n            >\n                <InputHelperText\n                    touched={isTouched || isSubmitted || fetchError}\n                    error={error?.message || fetchError?.message}\n                    helperText={helperText}\n                />\n            </FormHelperText>\n        </StyledFormControl>\n    );\n};\n\nconst sanitizeRestProps = ({\n    refetch,\n    setFilter,\n    setPagination,\n    setSort,\n    loaded,\n    touched,\n    ...rest\n}: any) => sanitizeInputRestProps(rest);\n\nCheckboxGroupInput.propTypes = {\n    choices: PropTypes.arrayOf(PropTypes.any),\n    className: PropTypes.string,\n    source: PropTypes.string,\n    optionText: PropTypes.oneOfType([\n        PropTypes.string,\n        PropTypes.func,\n        PropTypes.element,\n    ]),\n    optionValue: PropTypes.string,\n    row: PropTypes.bool,\n    resource: PropTypes.string,\n    translateChoice: PropTypes.bool,\n};\n\nexport type CheckboxGroupInputProps = Omit<CommonInputProps, 'source'> &\n    ChoicesProps &\n    CheckboxProps &\n    FormControlProps & {\n        options?: CheckboxProps;\n        row?: boolean;\n        // Optional as this input can be used inside a ReferenceInput\n        source?: string;\n        labelPlacement?: 'bottom' | 'end' | 'start' | 'top';\n    };\n\nconst PREFIX = 'RaCheckboxGroupInput';\n\nexport const CheckboxGroupInputClasses = {\n    label: `${PREFIX}-label`,\n    helperText: `${PREFIX}-helperText`,\n};\n\nconst StyledFormControl = styled(FormControl, {\n    name: PREFIX,\n    overridesResolver: (props, styles) => styles.root,\n})(({ theme }) => ({\n    [`& .${CheckboxGroupInputClasses.label}`]: {\n        transform: 'translate(0, 4px) scale(0.75)',\n        transformOrigin: `top ${theme.direction === 'ltr' ? 'left' : 'right'}`,\n    },\n    [`& .${CheckboxGroupInputClasses.helperText}`]: {\n        marginLeft: 0,\n        marginRight: 0,\n    },\n}));\n"]},"metadata":{},"sourceType":"module"}