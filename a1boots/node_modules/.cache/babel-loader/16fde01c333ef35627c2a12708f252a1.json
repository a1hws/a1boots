{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { useCallback, useMemo } from 'react';\nimport { useFormContext, useWatch } from 'react-hook-form';\nimport { useGetList, useGetManyAggregate } from '../../dataProvider';\nimport { useReferenceParams } from './useReferenceParams';\n/**\n * Prepare data for the ReferenceArrayInput components\n *\n * @example\n *\n * const { allChoices, availableChoices, selectedChoices, error, isFetching, isLoading } = useReferenceArrayInputController({\n *      record: { referenceIds: ['id1', 'id2']};\n *      reference: 'reference';\n *      resource: 'resource';\n *      source: 'referenceIds';\n * });\n *\n * @param {Object} props\n * @param {Object} props.record The current resource record\n * @param {string} props.reference The linked resource name\n * @param {string} props.resource The current resource name\n * @param {string} props.source The key of the linked resource identifier\n *\n * @param {Props} props\n *\n * @return {Object} controllerProps Fetched data and callbacks for the ReferenceArrayInput components\n */\n\nexport var useReferenceArrayInputController = function (props) {\n  var _a;\n\n  var debounce = props.debounce,\n      enableGetChoices = props.enableGetChoices,\n      filter = props.filter,\n      _b = props.page,\n      initialPage = _b === void 0 ? 1 : _b,\n      _c = props.perPage,\n      initialPerPage = _c === void 0 ? 25 : _c,\n      _d = props.sort,\n      initialSort = _d === void 0 ? {\n    field: 'id',\n    order: 'DESC'\n  } : _d,\n      _e = props.queryOptions,\n      queryOptions = _e === void 0 ? {} : _e,\n      reference = props.reference,\n      source = props.source;\n  var getValues = useFormContext().getValues; // When we change the defaultValue of the child input using react-hook-form resetField function,\n  // useWatch does not seem to get the new value. We fallback to getValues to get it.\n\n  var value = (_a = useWatch({\n    name: source\n  })) !== null && _a !== void 0 ? _a : getValues(source);\n\n  var meta = queryOptions.meta,\n      otherQueryOptions = __rest(queryOptions, [\"meta\"]);\n  /**\n   * Get the records related to the current value (with getMany)\n   */\n\n\n  var _f = useGetManyAggregate(reference, {\n    ids: value || EmptyArray,\n    meta: meta\n  }, {\n    enabled: value != null && value.length > 0\n  }),\n      referenceRecords = _f.data,\n      errorGetMany = _f.error,\n      isLoadingGetMany = _f.isLoading,\n      isFetchingGetMany = _f.isFetching,\n      refetchGetMany = _f.refetch;\n\n  var _g = useReferenceParams({\n    resource: reference,\n    page: initialPage,\n    perPage: initialPerPage,\n    sort: initialSort,\n    debounce: debounce,\n    filter: filter\n  }),\n      params = _g[0],\n      paramsModifiers = _g[1]; // filter out not found references - happens when the dataProvider doesn't guarantee referential integrity\n\n\n  var finalReferenceRecords = referenceRecords ? referenceRecords.filter(Boolean) : [];\n  var isGetMatchingEnabled = enableGetChoices ? enableGetChoices(params.filterValues) : true;\n\n  var _h = useGetList(reference, {\n    pagination: {\n      page: params.page,\n      perPage: params.perPage\n    },\n    sort: {\n      field: params.sort,\n      order: params.order\n    },\n    filter: __assign(__assign({}, params.filter), filter),\n    meta: meta\n  }, __assign({\n    retry: false,\n    enabled: isGetMatchingEnabled,\n    keepPreviousData: true\n  }, otherQueryOptions)),\n      matchingReferences = _h.data,\n      total = _h.total,\n      pageInfo = _h.pageInfo,\n      errorGetList = _h.error,\n      isLoadingGetList = _h.isLoading,\n      isFetchingGetList = _h.isFetching,\n      refetchGetMatching = _h.refetch; // We merge the currently selected records with the matching ones, otherwise\n  // the component displaying the currently selected records may fail\n\n\n  var finalMatchingReferences = matchingReferences && matchingReferences.length > 0 ? mergeReferences(matchingReferences, finalReferenceRecords) : finalReferenceRecords.length > 0 ? finalReferenceRecords : matchingReferences;\n  var refetch = useCallback(function () {\n    refetchGetMany();\n    refetchGetMatching();\n  }, [refetchGetMany, refetchGetMatching]);\n  var currentSort = useMemo(function () {\n    return {\n      field: params.sort,\n      order: params.order\n    };\n  }, [params.sort, params.order]);\n  return {\n    sort: currentSort,\n    allChoices: finalMatchingReferences,\n    availableChoices: matchingReferences,\n    selectedChoices: finalReferenceRecords,\n    displayedFilters: params.displayedFilters,\n    error: errorGetMany || errorGetList,\n    filter: filter,\n    filterValues: params.filterValues,\n    hideFilter: paramsModifiers.hideFilter,\n    isFetching: isFetchingGetMany || isFetchingGetList,\n    isLoading: isLoadingGetMany || isLoadingGetList,\n    page: params.page,\n    perPage: params.perPage,\n    refetch: refetch,\n    resource: reference,\n    setFilters: paramsModifiers.setFilters,\n    setPage: paramsModifiers.setPage,\n    setPerPage: paramsModifiers.setPerPage,\n    setSort: paramsModifiers.setSort,\n    showFilter: paramsModifiers.showFilter,\n    source: source,\n    total: total,\n    hasNextPage: pageInfo ? pageInfo.hasNextPage : total != null ? params.page * params.perPage < total : undefined,\n    hasPreviousPage: pageInfo ? pageInfo.hasPreviousPage : params.page > 1,\n    isFromReference: true\n  };\n};\nvar EmptyArray = []; // concatenate and deduplicate two lists of records\n\nvar mergeReferences = function (ref1, ref2) {\n  var res = __spreadArray([], ref1, true);\n\n  var ids = ref1.map(function (ref) {\n    return ref.id;\n  });\n  ref2.forEach(function (ref) {\n    if (!ids.includes(ref.id)) {\n      ids.push(ref.id);\n      res.push(ref);\n    }\n  });\n  return res;\n};","map":{"version":3,"mappings":"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","names":["useCallback","useMemo","useFormContext","useWatch","useGetList","useGetManyAggregate","useReferenceParams","useReferenceArrayInputController","props","enableGetChoices","filter","_b","initialPage","_c","initialPerPage","_d","initialSort","field","order","_e","queryOptions","reference","source","getValues","value","name","_a","otherQueryOptions","ids","EmptyArray","meta","enabled","length","referenceRecords","errorGetMany","isLoadingGetMany","isFetchingGetMany","refetchGetMany","resource","page","perPage","sort","debounce","params","paramsModifiers","finalReferenceRecords","Boolean","isGetMatchingEnabled","filterValues","pagination","__assign","retry","keepPreviousData","matchingReferences","total","pageInfo","errorGetList","isLoadingGetList","isFetchingGetList","refetchGetMatching","finalMatchingReferences","mergeReferences","refetch","currentSort","allChoices","availableChoices","selectedChoices","displayedFilters","error","hideFilter","isFetching","isLoading","setFilters","setPage","setPerPage","setSort","showFilter","hasNextPage","undefined","hasPreviousPage","isFromReference","ref1","ref2","res","map","id","forEach","includes","ref","push"],"sources":["/var/www/a1boots/node_modules/ra-core/src/controller/input/useReferenceArrayInputController.ts"],"sourcesContent":["import { useCallback, useMemo } from 'react';\nimport { useFormContext, useWatch } from 'react-hook-form';\n\nimport { FilterPayload, RaRecord, SortPayload } from '../../types';\nimport { useGetList, useGetManyAggregate } from '../../dataProvider';\nimport { useReferenceParams } from './useReferenceParams';\nimport { ChoicesContextValue } from '../../form';\nimport { UseQueryOptions } from 'react-query';\n\n/**\n * Prepare data for the ReferenceArrayInput components\n *\n * @example\n *\n * const { allChoices, availableChoices, selectedChoices, error, isFetching, isLoading } = useReferenceArrayInputController({\n *      record: { referenceIds: ['id1', 'id2']};\n *      reference: 'reference';\n *      resource: 'resource';\n *      source: 'referenceIds';\n * });\n *\n * @param {Object} props\n * @param {Object} props.record The current resource record\n * @param {string} props.reference The linked resource name\n * @param {string} props.resource The current resource name\n * @param {string} props.source The key of the linked resource identifier\n *\n * @param {Props} props\n *\n * @return {Object} controllerProps Fetched data and callbacks for the ReferenceArrayInput components\n */\nexport const useReferenceArrayInputController = <\n    RecordType extends RaRecord = any\n>(\n    props: UseReferenceArrayInputParams<RecordType>\n): ChoicesContextValue<RecordType> => {\n    const {\n        debounce,\n        enableGetChoices,\n        filter,\n        page: initialPage = 1,\n        perPage: initialPerPage = 25,\n        sort: initialSort = { field: 'id', order: 'DESC' },\n        queryOptions = {},\n        reference,\n        source,\n    } = props;\n    const { getValues } = useFormContext();\n    // When we change the defaultValue of the child input using react-hook-form resetField function,\n    // useWatch does not seem to get the new value. We fallback to getValues to get it.\n    const value = useWatch({ name: source }) ?? getValues(source);\n    const { meta, ...otherQueryOptions } = queryOptions;\n\n    /**\n     * Get the records related to the current value (with getMany)\n     */\n    const {\n        data: referenceRecords,\n        error: errorGetMany,\n        isLoading: isLoadingGetMany,\n        isFetching: isFetchingGetMany,\n        refetch: refetchGetMany,\n    } = useGetManyAggregate<RecordType>(\n        reference,\n        {\n            ids: value || EmptyArray,\n            meta,\n        },\n        {\n            enabled: value != null && value.length > 0,\n        }\n    );\n\n    const [params, paramsModifiers] = useReferenceParams({\n        resource: reference,\n        page: initialPage,\n        perPage: initialPerPage,\n        sort: initialSort,\n        debounce,\n        filter,\n    });\n\n    // filter out not found references - happens when the dataProvider doesn't guarantee referential integrity\n    const finalReferenceRecords = referenceRecords\n        ? referenceRecords.filter(Boolean)\n        : [];\n\n    const isGetMatchingEnabled = enableGetChoices\n        ? enableGetChoices(params.filterValues)\n        : true;\n\n    const {\n        data: matchingReferences,\n        total,\n        pageInfo,\n        error: errorGetList,\n        isLoading: isLoadingGetList,\n        isFetching: isFetchingGetList,\n        refetch: refetchGetMatching,\n    } = useGetList<RecordType>(\n        reference,\n        {\n            pagination: {\n                page: params.page,\n                perPage: params.perPage,\n            },\n            sort: { field: params.sort, order: params.order },\n            filter: { ...params.filter, ...filter },\n            meta,\n        },\n        {\n            retry: false,\n            enabled: isGetMatchingEnabled,\n            keepPreviousData: true,\n            ...otherQueryOptions,\n        }\n    );\n\n    // We merge the currently selected records with the matching ones, otherwise\n    // the component displaying the currently selected records may fail\n    const finalMatchingReferences =\n        matchingReferences && matchingReferences.length > 0\n            ? mergeReferences(matchingReferences, finalReferenceRecords)\n            : finalReferenceRecords.length > 0\n            ? finalReferenceRecords\n            : matchingReferences;\n\n    const refetch = useCallback(() => {\n        refetchGetMany();\n        refetchGetMatching();\n    }, [refetchGetMany, refetchGetMatching]);\n\n    const currentSort = useMemo(\n        () => ({\n            field: params.sort,\n            order: params.order,\n        }),\n        [params.sort, params.order]\n    );\n    return {\n        sort: currentSort,\n        allChoices: finalMatchingReferences,\n        availableChoices: matchingReferences,\n        selectedChoices: finalReferenceRecords,\n        displayedFilters: params.displayedFilters,\n        error: errorGetMany || errorGetList,\n        filter,\n        filterValues: params.filterValues,\n        hideFilter: paramsModifiers.hideFilter,\n        isFetching: isFetchingGetMany || isFetchingGetList,\n        isLoading: isLoadingGetMany || isLoadingGetList,\n        page: params.page,\n        perPage: params.perPage,\n        refetch,\n        resource: reference,\n        setFilters: paramsModifiers.setFilters,\n        setPage: paramsModifiers.setPage,\n        setPerPage: paramsModifiers.setPerPage,\n        setSort: paramsModifiers.setSort,\n        showFilter: paramsModifiers.showFilter,\n        source,\n        total: total,\n        hasNextPage: pageInfo\n            ? pageInfo.hasNextPage\n            : total != null\n            ? params.page * params.perPage < total\n            : undefined,\n        hasPreviousPage: pageInfo ? pageInfo.hasPreviousPage : params.page > 1,\n        isFromReference: true,\n    };\n};\n\nconst EmptyArray = [];\n\n// concatenate and deduplicate two lists of records\nconst mergeReferences = <RecordType extends RaRecord = any>(\n    ref1: RecordType[],\n    ref2: RecordType[]\n): RecordType[] => {\n    const res = [...ref1];\n    const ids = ref1.map(ref => ref.id);\n    ref2.forEach(ref => {\n        if (!ids.includes(ref.id)) {\n            ids.push(ref.id);\n            res.push(ref);\n        }\n    });\n    return res;\n};\n\nexport interface UseReferenceArrayInputParams<\n    RecordType extends RaRecord = any\n> {\n    debounce?: number;\n    filter?: FilterPayload;\n    queryOptions?: UseQueryOptions<{\n        data: RecordType[];\n        total?: number;\n        pageInfo?: {\n            hasNextPage?: boolean;\n            hasPreviousPage?: boolean;\n        };\n    }> & { meta?: any };\n    page?: number;\n    perPage?: number;\n    record?: RecordType;\n    reference: string;\n    resource?: string;\n    sort?: SortPayload;\n    source: string;\n    enableGetChoices?: (filters: any) => boolean;\n}\n"]},"metadata":{},"sourceType":"module"}