{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { useMemo } from 'react';\nimport { useQueryClient, useQuery, hashQueryKey } from 'react-query';\nimport union from 'lodash/union';\nimport { useDataProvider } from './useDataProvider';\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, isFetching: true, refetch }\n * - success: { data: [data from response], isLoading: false, isFetching: false, refetch }\n * - error: { error: [error from response], isLoading: false, isFetching: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetManyAggregate('tags', [1, 2, 3]);\n * useGetManyAggregate('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider.getMany('tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n\n * @returns The current request state. Destructure as { data, error, isLoading, isFetching, refetch }.\n *\n * @example\n *\n * import { useGetManyAggregate, useRecordContext } from 'react-admin';\n *\n * const PostTags = () => {\n *     const record = useRecordContext();\n *     const { data, isLoading, error } = useGetManyAggregate('tags', { ids: record.tagIds });\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\n\nexport var useGetManyAggregate = function (resource, params, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var dataProvider = useDataProvider();\n  var queryClient = useQueryClient();\n  var queryCache = queryClient.getQueryCache();\n  var ids = params.ids,\n      meta = params.meta;\n  var placeholderData = useMemo(function () {\n    var records = (Array.isArray(ids) ? ids : [ids]).map(function (id) {\n      var _a, _b;\n\n      var queryHash = hashQueryKey([resource, 'getOne', {\n        id: String(id),\n        meta: meta\n      }]);\n      return (_b = (_a = queryCache.get(queryHash)) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.data;\n    });\n\n    if (records.some(function (record) {\n      return record === undefined;\n    })) {\n      return undefined;\n    } else {\n      return records;\n    }\n  }, [ids, queryCache, resource, meta]);\n  return useQuery([resource, 'getMany', {\n    ids: (Array.isArray(ids) ? ids : [ids]).map(function (id) {\n      return String(id);\n    }),\n    meta: meta\n  }], function () {\n    return new Promise(function (resolve, reject) {\n      if (!ids || ids.length === 0) {\n        // no need to call the dataProvider\n        return resolve([]);\n      } // debounced / batched fetch\n\n\n      return callGetManyQueries({\n        resource: resource,\n        ids: ids,\n        meta: meta,\n        resolve: resolve,\n        reject: reject,\n        dataProvider: dataProvider,\n        queryClient: queryClient\n      });\n    });\n  }, __assign({\n    placeholderData: placeholderData,\n    onSuccess: function (data) {\n      // optimistically populate the getOne cache\n      (data !== null && data !== void 0 ? data : []).forEach(function (record) {\n        queryClient.setQueryData([resource, 'getOne', {\n          id: String(record.id),\n          meta: meta\n        }], function (oldRecord) {\n          return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;\n        });\n      });\n    },\n    retry: false\n  }, options));\n};\n/**\n * Batch all calls to a function into one single call with the arguments of all the calls.\n *\n * @example\n * let sum = 0;\n * const add = (args) => { sum = args.reduce((arg, total) => total + arg, 0); };\n * const addBatched = batch(add);\n * addBatched(2);\n * addBatched(8);\n * // add will be called once with arguments [2, 8]\n * // and sum will be equal to 10\n */\n\nvar batch = function (fn) {\n  var capturedArgs = [];\n  var timeout = null;\n  return function (arg) {\n    capturedArgs.push(arg);\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      timeout = null;\n      fn(__spreadArray([], capturedArgs, true));\n      capturedArgs = [];\n    }, 0);\n  };\n};\n/**\n * Group and execute all calls to the dataProvider.getMany() method for the current tick\n *\n * Thanks to batch(), this function executes at most once per tick,\n * whatever the number of calls to useGetManyAggregate().\n */\n\n\nvar callGetManyQueries = batch(function (calls) {\n  var dataProvider = calls[0].dataProvider;\n  var queryClient = calls[0].queryClient;\n  /**\n   * Aggregate calls by resource\n   *\n   * callsByResource will look like:\n   * {\n   *     posts: [{ resource, ids, resolve, reject, dataProvider, queryClient }, ...],\n   *     tags: [{ resource, ids, resolve, reject, dataProvider, queryClient }, ...],\n   * }\n   */\n\n  var callsByResource = calls.reduce(function (acc, callArgs) {\n    if (!acc[callArgs.resource]) {\n      acc[callArgs.resource] = [];\n    }\n\n    acc[callArgs.resource].push(callArgs);\n    return acc;\n  }, {});\n  /**\n   * For each resource, aggregate ids and call dataProvider.getMany() once\n   */\n\n  Object.keys(callsByResource).forEach(function (resource) {\n    var callsForResource = callsByResource[resource];\n    /**\n     * Extract ids from queries, aggregate and deduplicate them\n     *\n     * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n     */\n\n    var aggregatedIds = callsForResource.reduce(function (acc, _a) {\n      var ids = _a.ids;\n      return union(acc, ids);\n    }, []) // concat + unique\n    .filter(function (v) {\n      return v != null && v !== '';\n    }); // remove null values\n\n    var uniqueMeta = callsForResource.reduce(function (acc, _a) {\n      var meta = _a.meta;\n      return meta || acc;\n    }, undefined);\n\n    if (aggregatedIds.length === 0) {\n      // no need to call the data provider if all the ids are null\n      callsForResource.forEach(function (_a) {\n        var resolve = _a.resolve;\n        resolve([]);\n      });\n      return;\n    }\n\n    var callThatHasAllAggregatedIds = callsForResource.find(function (_a) {\n      var ids = _a.ids;\n      return JSON.stringify(ids) === JSON.stringify(aggregatedIds);\n    });\n\n    if (callThatHasAllAggregatedIds) {\n      // There is only one call (no aggregation), or one of the calls has the same ids as the sum of all calls.\n      // Either way, we can't trigger a new fetchQuery with the same signature, as it's already pending.\n      // Therefore, we reply with the dataProvider\n      var dataProvider_1 = callThatHasAllAggregatedIds.dataProvider,\n          resource_1 = callThatHasAllAggregatedIds.resource,\n          ids = callThatHasAllAggregatedIds.ids,\n          meta = callThatHasAllAggregatedIds.meta;\n      dataProvider_1.getMany(resource_1, {\n        ids: ids,\n        meta: meta\n      }).then(function (_a) {\n        var data = _a.data;\n        return data;\n      }).then(function (data) {\n        // We must then resolve all the pending calls with the data they requested\n        callsForResource.forEach(function (_a) {\n          var ids = _a.ids,\n              resolve = _a.resolve;\n          resolve(data.filter(function (record) {\n            return ids.map(function (id) {\n              return String(id);\n            }).includes(String(record.id));\n          }));\n        });\n      }, function (error) {\n        // All pending calls must also receive the error\n        callsForResource.forEach(function (_a) {\n          var reject = _a.reject;\n          reject(error);\n        });\n      });\n      return;\n    }\n    /**\n     * Call dataProvider.getMany() with the aggregatedIds,\n     * and resolve each of the promises using the results\n     */\n\n\n    queryClient.fetchQuery([resource, 'getMany', {\n      ids: aggregatedIds.map(function (id) {\n        return String(id);\n      }),\n      meta: uniqueMeta\n    }], function () {\n      return dataProvider.getMany(resource, {\n        ids: aggregatedIds,\n        meta: uniqueMeta\n      }).then(function (_a) {\n        var data = _a.data;\n        return data;\n      });\n    }).then(function (data) {\n      callsForResource.forEach(function (_a) {\n        var ids = _a.ids,\n            resolve = _a.resolve;\n        resolve(data.filter(function (record) {\n          return ids.map(function (id) {\n            return String(id);\n          }).includes(String(record.id));\n        }));\n      });\n    }).catch(function (error) {\n      return callsForResource.forEach(function (_a) {\n        var reject = _a.reject;\n        return reject(error);\n      });\n    });\n  });\n});","map":{"version":3,"mappings":"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","names":["useMemo","useQueryClient","useQuery","hashQueryKey","union","useDataProvider","useGetManyAggregate","resource","params","options","dataProvider","queryClient","queryCache","getQueryCache","meta","placeholderData","records","Array","isArray","ids","map","queryHash","id","String","get","_a","state","_b","data","some","undefined","Promise","resolve","reject","length","callGetManyQueries","__assign","onSuccess","forEach","setQueryData","record","retry","batch","capturedArgs","timeout","arg","push","clearTimeout","setTimeout","fn","calls","callsByResource","reduce","acc","callArgs","Object","keys","callsForResource","aggregatedIds","filter","v","uniqueMeta","callThatHasAllAggregatedIds","find","stringify","JSON","resource_1","dataProvider_1","getMany","then","includes","error","fetchQuery","catch"],"sources":["/var/www/a1boots/node_modules/ra-core/src/dataProvider/useGetManyAggregate.ts"],"sourcesContent":["import { useMemo } from 'react';\nimport {\n    QueryClient,\n    useQueryClient,\n    useQuery,\n    UseQueryOptions,\n    hashQueryKey,\n} from 'react-query';\nimport union from 'lodash/union';\n\nimport { UseGetManyHookValue } from './useGetMany';\nimport { Identifier, RaRecord, GetManyParams, DataProvider } from '../types';\nimport { useDataProvider } from './useDataProvider';\n\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, isFetching: true, refetch }\n * - success: { data: [data from response], isLoading: false, isFetching: false, refetch }\n * - error: { error: [error from response], isLoading: false, isFetching: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetManyAggregate('tags', [1, 2, 3]);\n * useGetManyAggregate('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider.getMany('tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n\n * @returns The current request state. Destructure as { data, error, isLoading, isFetching, refetch }.\n *\n * @example\n *\n * import { useGetManyAggregate, useRecordContext } from 'react-admin';\n *\n * const PostTags = () => {\n *     const record = useRecordContext();\n *     const { data, isLoading, error } = useGetManyAggregate('tags', { ids: record.tagIds });\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\nexport const useGetManyAggregate = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: GetManyParams,\n    options: UseQueryOptions<RecordType[], Error> = {}\n): UseGetManyHookValue<RecordType> => {\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const queryCache = queryClient.getQueryCache();\n    const { ids, meta } = params;\n    const placeholderData = useMemo(() => {\n        const records = (Array.isArray(ids) ? ids : [ids]).map(id => {\n            const queryHash = hashQueryKey([\n                resource,\n                'getOne',\n                { id: String(id), meta },\n            ]);\n            return queryCache.get<RecordType>(queryHash)?.state?.data;\n        });\n        if (records.some(record => record === undefined)) {\n            return undefined;\n        } else {\n            return records as RecordType[];\n        }\n    }, [ids, queryCache, resource, meta]);\n\n    return useQuery<RecordType[], Error, RecordType[]>(\n        [\n            resource,\n            'getMany',\n            {\n                ids: (Array.isArray(ids) ? ids : [ids]).map(id => String(id)),\n                meta,\n            },\n        ],\n        () =>\n            new Promise((resolve, reject) => {\n                if (!ids || ids.length === 0) {\n                    // no need to call the dataProvider\n                    return resolve([]);\n                }\n                // debounced / batched fetch\n                return callGetManyQueries({\n                    resource,\n                    ids,\n                    meta,\n                    resolve,\n                    reject,\n                    dataProvider,\n                    queryClient,\n                });\n            }),\n        {\n            placeholderData,\n            onSuccess: data => {\n                // optimistically populate the getOne cache\n                (data ?? []).forEach(record => {\n                    queryClient.setQueryData(\n                        [resource, 'getOne', { id: String(record.id), meta }],\n                        oldRecord => oldRecord ?? record\n                    );\n                });\n            },\n            retry: false,\n            ...options,\n        }\n    );\n};\n\n/**\n * Batch all calls to a function into one single call with the arguments of all the calls.\n *\n * @example\n * let sum = 0;\n * const add = (args) => { sum = args.reduce((arg, total) => total + arg, 0); };\n * const addBatched = batch(add);\n * addBatched(2);\n * addBatched(8);\n * // add will be called once with arguments [2, 8]\n * // and sum will be equal to 10\n */\nconst batch = fn => {\n    let capturedArgs: any[] = [];\n    let timeout: ReturnType<typeof setTimeout> | null = null;\n    return (arg: any) => {\n        capturedArgs.push(arg);\n        if (timeout) clearTimeout(timeout);\n        timeout = setTimeout(() => {\n            timeout = null;\n            fn([...capturedArgs]);\n            capturedArgs = [];\n        }, 0);\n    };\n};\n\ninterface GetManyCallArgs {\n    resource: string;\n    ids: Identifier[];\n    meta?: any;\n    resolve: (data: any[]) => void;\n    reject: (error?: any) => void;\n    dataProvider: DataProvider;\n    queryClient: QueryClient;\n}\n\n/**\n * Group and execute all calls to the dataProvider.getMany() method for the current tick\n *\n * Thanks to batch(), this function executes at most once per tick,\n * whatever the number of calls to useGetManyAggregate().\n */\nconst callGetManyQueries = batch((calls: GetManyCallArgs[]) => {\n    const dataProvider = calls[0].dataProvider;\n    const queryClient = calls[0].queryClient;\n\n    /**\n     * Aggregate calls by resource\n     *\n     * callsByResource will look like:\n     * {\n     *     posts: [{ resource, ids, resolve, reject, dataProvider, queryClient }, ...],\n     *     tags: [{ resource, ids, resolve, reject, dataProvider, queryClient }, ...],\n     * }\n     */\n    const callsByResource = calls.reduce((acc, callArgs) => {\n        if (!acc[callArgs.resource]) {\n            acc[callArgs.resource] = [];\n        }\n        acc[callArgs.resource].push(callArgs);\n        return acc;\n    }, {} as { [resource: string]: GetManyCallArgs[] });\n\n    /**\n     * For each resource, aggregate ids and call dataProvider.getMany() once\n     */\n    Object.keys(callsByResource).forEach(resource => {\n        const callsForResource = callsByResource[resource];\n\n        /**\n         * Extract ids from queries, aggregate and deduplicate them\n         *\n         * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n         */\n        const aggregatedIds = callsForResource\n            .reduce((acc, { ids }) => union(acc, ids), []) // concat + unique\n            .filter(v => v != null && v !== ''); // remove null values\n\n        const uniqueMeta = callsForResource.reduce(\n            (acc, { meta }) => meta || acc,\n            undefined\n        );\n\n        if (aggregatedIds.length === 0) {\n            // no need to call the data provider if all the ids are null\n            callsForResource.forEach(({ resolve }) => {\n                resolve([]);\n            });\n            return;\n        }\n\n        const callThatHasAllAggregatedIds = callsForResource.find(\n            ({ ids }) => JSON.stringify(ids) === JSON.stringify(aggregatedIds)\n        );\n        if (callThatHasAllAggregatedIds) {\n            // There is only one call (no aggregation), or one of the calls has the same ids as the sum of all calls.\n            // Either way, we can't trigger a new fetchQuery with the same signature, as it's already pending.\n            // Therefore, we reply with the dataProvider\n            const {\n                dataProvider,\n                resource,\n                ids,\n                meta,\n            } = callThatHasAllAggregatedIds;\n\n            dataProvider\n                .getMany<any>(resource, { ids, meta })\n                .then(({ data }) => data)\n                .then(\n                    data => {\n                        // We must then resolve all the pending calls with the data they requested\n                        callsForResource.forEach(({ ids, resolve }) => {\n                            resolve(\n                                data.filter(record =>\n                                    ids\n                                        .map(id => String(id))\n                                        .includes(String(record.id))\n                                )\n                            );\n                        });\n                    },\n                    error => {\n                        // All pending calls must also receive the error\n                        callsForResource.forEach(({ reject }) => {\n                            reject(error);\n                        });\n                    }\n                );\n            return;\n        }\n\n        /**\n         * Call dataProvider.getMany() with the aggregatedIds,\n         * and resolve each of the promises using the results\n         */\n        queryClient\n            .fetchQuery<any[], Error, any[]>(\n                [\n                    resource,\n                    'getMany',\n                    {\n                        ids: aggregatedIds.map(id => String(id)),\n                        meta: uniqueMeta,\n                    },\n                ],\n                () =>\n                    dataProvider\n                        .getMany<any>(resource, {\n                            ids: aggregatedIds,\n                            meta: uniqueMeta,\n                        })\n                        .then(({ data }) => data)\n            )\n            .then(data => {\n                callsForResource.forEach(({ ids, resolve }) => {\n                    resolve(\n                        data.filter(record =>\n                            ids\n                                .map(id => String(id))\n                                .includes(String(record.id))\n                        )\n                    );\n                });\n            })\n            .catch(error =>\n                callsForResource.forEach(({ reject }) => reject(error))\n            );\n    });\n});\n"]},"metadata":{},"sourceType":"module"}