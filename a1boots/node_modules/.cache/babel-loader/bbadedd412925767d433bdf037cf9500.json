{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { useInfiniteQuery, useQueryClient } from 'react-query';\nimport { useDataProvider } from './useDataProvider';\n/**\n * Call the dataProvider.getList() method and return the resolved result\n * as well as the loading state. The return from useInfiniteGetList is equivalent to the return from react-hook form useInfiniteQuery.\n *\n * @see https://react-query-v3.tanstack.com/reference/useInfiniteQuery\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getList parameters { pagination, sort, filter, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { fetchNextPage(); } }\n *\n * @typedef Params\n * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }\n * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }\n * @prop params.filter The request filters, e.g. { title: 'hello, world' }\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, total, error, isLoading, isSuccess, hasNextPage, fetchNextPage }.\n *\n * @example\n *\n * import { useInfinteGetList } from 'react-admin';\n *\n * const LatestNews = () => {\n *     const { data, total, isLoading, error, hasNextPage, fetchNextPage } = useInfiniteGetList(\n *         'posts',\n *         { pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *        <>\n *            <ul>\n *                {data?.pages.map(page => {\n *                    return page.data.map(post => (\n *                        <li key={post.id}>{post.title}</li>\n *                    ));\n *                })}\n *            </ul>\n *            <div>\n *                <button disabled={!hasNextPage} onClick={() => fetchNextPage()}>\n *                    Fetch next page\n *                </button>\n *            </div>\n *        </>\n *    );\n * };\n */\n\nexport var useInfiniteGetList = function useInfiniteGetList(resource, params, options) {\n  var _a, _b;\n\n  if (params === void 0) {\n    params = {};\n  }\n\n  var _c = params.pagination,\n      pagination = _c === void 0 ? {\n    page: 1,\n    perPage: 25\n  } : _c,\n      _d = params.sort,\n      sort = _d === void 0 ? {\n    field: 'id',\n    order: 'DESC'\n  } : _d,\n      _e = params.filter,\n      filter = _e === void 0 ? {} : _e,\n      meta = params.meta;\n  var dataProvider = useDataProvider();\n  var queryClient = useQueryClient();\n  var result = useInfiniteQuery([resource, 'getInfiniteList', {\n    pagination: pagination,\n    sort: sort,\n    filter: filter,\n    meta: meta\n  }], function (_a) {\n    var _b = _a.pageParam,\n        pageParam = _b === void 0 ? pagination.page : _b;\n    return dataProvider.getList(resource, {\n      pagination: {\n        page: pageParam,\n        perPage: pagination.perPage\n      },\n      sort: sort,\n      filter: filter,\n      meta: meta\n    }).then(function (_a) {\n      var data = _a.data,\n          pageInfo = _a.pageInfo,\n          total = _a.total;\n      return {\n        data: data,\n        total: total,\n        pageParam: pageParam,\n        pageInfo: pageInfo\n      };\n    });\n  }, __assign(__assign({\n    onSuccess: function onSuccess(data) {\n      // optimistically populate the getOne cache\n      data.pages.forEach(function (page) {\n        page.data.forEach(function (record) {\n          queryClient.setQueryData([resource, 'getOne', {\n            id: String(record.id),\n            meta: meta\n          }], function (oldRecord) {\n            return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;\n          });\n        });\n      });\n    }\n  }, options), {\n    getNextPageParam: function getNextPageParam(lastLoadedPage) {\n      if (lastLoadedPage.pageInfo) {\n        return lastLoadedPage.pageInfo.hasNextPage ? lastLoadedPage.pageParam + 1 : undefined;\n      }\n\n      var totalPages = Math.ceil((lastLoadedPage.total || 0) / pagination.perPage);\n      return lastLoadedPage.pageParam < totalPages ? Number(lastLoadedPage.pageParam) + 1 : undefined;\n    },\n    getPreviousPageParam: function getPreviousPageParam(lastLoadedPage) {\n      if (lastLoadedPage.pageInfo) {\n        return lastLoadedPage.pageInfo.hasPreviousPage ? lastLoadedPage.pageParam - 1 : undefined;\n      }\n\n      return lastLoadedPage.pageParam === 1 ? undefined : lastLoadedPage.pageParam - 1;\n    }\n  }));\n  return result.data ? __assign(__assign({}, result), {\n    data: result.data,\n    total: ((_b = (_a = result.data) === null || _a === void 0 ? void 0 : _a.pages[0]) === null || _b === void 0 ? void 0 : _b.total) || undefined\n  }) : result;\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;AAAA,SACIA,gBADJ,EAIIC,cAJJ,QAKO,aALP;AAQA,SAASC,eAAT,QAAgC,mBAAhC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoDA,OAAO,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB,CAC9BC,QAD8B,EAE9BC,MAF8B,EAG9BC,OAH8B,EAG6C;;;EAD3E;IAAAD;EAAmC;;EAI/B,SAIAA,MAAM,WAJN;EAAA,cAAU,mBAAG;IAAEE,IAAI,EAAE,CAAR;IAAWC,OAAO,EAAE;EAApB,CAAH,GAA2BC,EAArC;EAAA,IACAC,KAGAL,MAAM,KAJN;EAAA,IACAM,IAAI,mBAAG;IAAEC,KAAK,EAAE,IAAT;IAAeC,KAAK,EAAE;EAAtB,CAAH,GAAiCH,EADrC;EAAA,IAEAI,KAEAT,MAAM,OAJN;EAAA,IAEAU,MAAM,mBAAG,EAAH,GAAKD,EAFX;EAAA,IAGAE,IAAI,GACJX,MAAM,KAJN;EAKJ,IAAMY,YAAY,GAAGf,eAAe,EAApC;EACA,IAAMgB,WAAW,GAAGjB,cAAc,EAAlC;EAEA,IAAMkB,MAAM,GAAGnB,gBAAgB,CAK3B,CAACI,QAAD,EAAW,iBAAX,EAA8B;IAAEgB,UAAU,YAAZ;IAAcT,IAAI,MAAlB;IAAoBI,MAAM,QAA1B;IAA4BC,IAAI;EAAhC,CAA9B,CAL2B,EAM3B,UAACK,EAAD,EAAgC;QAA7BC;QAAAC,SAAS,mBAAGH,UAAU,CAACb,IAAd,GAAkBe;IAC1B,mBAAY,CACPE,OADL,CACyBpB,QADzB,EACmC;MAC3BgB,UAAU,EAAE;QACRb,IAAI,EAAEgB,SADE;QAERf,OAAO,EAAEY,UAAU,CAACZ;MAFZ,CADe;MAK3BG,IAAI,MALuB;MAM3BI,MAAM,QANqB;MAO3BC,IAAI;IAPuB,CADnC,EAUKS,IAVL,CAUU,UAACJ,EAAD,EAA0B;UAAvBK,IAAI;UAAEC,QAAQ;UAAEC,KAAK;MAAO,OAAC;QAClCF,IAAI,MAD8B;QAElCE,KAAK,OAF6B;QAGlCL,SAAS,WAHyB;QAIlCI,QAAQ;MAJ0B,CAAD;IAKnC,CAfN;EAeO,CAtBgB,EAsBhBE;IAEPC,SAAS,EAAE,yBAAI;MACX;MACAJ,IAAI,CAACK,KAAL,CAAWC,OAAX,CAAmB,gBAAI;QACnBzB,IAAI,CAACmB,IAAL,CAAUM,OAAV,CAAkB,kBAAM;UACpBd,WAAW,CAACe,YAAZ,CACI,CACI7B,QADJ,EAEI,QAFJ,EAGI;YAAE8B,EAAE,EAAEC,MAAM,CAACC,MAAM,CAACF,EAAR,CAAZ;YAAyBlB,IAAI;UAA7B,CAHJ,CADJ,EAMI,qBAAS;YAAI,gBAAS,SAAT,aAAS,WAAT,eAAaoB,MAAb;UAAmB,CANpC;QAQH,CATD;MAUH,CAXD;IAYH;EAhBM,GAiBJ9B,OAjBI,GAiBG;IACV+B,gBAAgB,EAAE,0CAAc;MAC5B,IAAIC,cAAc,CAACX,QAAnB,EAA6B;QACzB,OAAOW,cAAc,CAACX,QAAf,CAAwBY,WAAxB,GACDD,cAAc,CAACf,SAAf,GAA2B,CAD1B,GAEDiB,SAFN;MAGH;;MACD,IAAMC,UAAU,GAAGC,IAAI,CAACC,IAAL,CACf,CAACL,cAAc,CAACV,KAAf,IAAwB,CAAzB,IAA8BR,UAAU,CAACZ,OAD1B,CAAnB;MAIA,OAAO8B,cAAc,CAACf,SAAf,GAA2BkB,UAA3B,GACDG,MAAM,CAACN,cAAc,CAACf,SAAhB,CAAN,GAAmC,CADlC,GAEDiB,SAFN;IAGH,CAdS;IAeVK,oBAAoB,EAAE,8CAAc;MAChC,IAAIP,cAAc,CAACX,QAAnB,EAA6B;QACzB,OAAOW,cAAc,CAACX,QAAf,CAAwBmB,eAAxB,GACDR,cAAc,CAACf,SAAf,GAA2B,CAD1B,GAEDiB,SAFN;MAGH;;MAED,OAAOF,cAAc,CAACf,SAAf,KAA6B,CAA7B,GACDiB,SADC,GAEDF,cAAc,CAACf,SAAf,GAA2B,CAFjC;IAGH;EAzBS,CAjBH,CAtBgB,CAA/B;EAoEA,OAAQJ,MAAM,CAACO,IAAP,GACHG,sBACQV,MADR,GACc;IACTO,IAAI,EAAEP,MAAM,CAACO,IADJ;IAETE,KAAK,EAAE,mBAAM,CAACF,IAAP,MAAW,IAAX,IAAWL,aAAX,GAAW,MAAX,GAAWA,GAAEU,KAAF,CAAQ,CAAR,CAAX,MAAqB,IAArB,IAAqBT,aAArB,GAAqB,MAArB,GAAqBA,GAAEM,KAAvB,KAAgCY;EAF9B,CADd,CADG,GAMFrB,MANN;AAYH,CA9FM","names":["useInfiniteQuery","useQueryClient","useDataProvider","useInfiniteGetList","resource","params","options","page","perPage","_c","_d","sort","field","order","_e","filter","meta","dataProvider","queryClient","result","pagination","_a","_b","pageParam","getList","then","data","pageInfo","total","__assign","onSuccess","pages","forEach","setQueryData","id","String","record","getNextPageParam","lastLoadedPage","hasNextPage","undefined","totalPages","Math","ceil","Number","getPreviousPageParam","hasPreviousPage"],"sources":["/var/www/a1boots/node_modules/ra-core/src/dataProvider/useInfiniteGetList.ts"],"sourcesContent":["import {\n    useInfiniteQuery,\n    UseInfiniteQueryOptions,\n    UseInfiniteQueryResult,\n    useQueryClient,\n} from 'react-query';\n\nimport { RaRecord, GetListParams, GetInfiniteListResult } from '../types';\nimport { useDataProvider } from './useDataProvider';\n\n/**\n * Call the dataProvider.getList() method and return the resolved result\n * as well as the loading state. The return from useInfiniteGetList is equivalent to the return from react-hook form useInfiniteQuery.\n *\n * @see https://react-query-v3.tanstack.com/reference/useInfiniteQuery\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getList parameters { pagination, sort, filter, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { fetchNextPage(); } }\n *\n * @typedef Params\n * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }\n * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }\n * @prop params.filter The request filters, e.g. { title: 'hello, world' }\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, total, error, isLoading, isSuccess, hasNextPage, fetchNextPage }.\n *\n * @example\n *\n * import { useInfinteGetList } from 'react-admin';\n *\n * const LatestNews = () => {\n *     const { data, total, isLoading, error, hasNextPage, fetchNextPage } = useInfiniteGetList(\n *         'posts',\n *         { pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *        <>\n *            <ul>\n *                {data?.pages.map(page => {\n *                    return page.data.map(post => (\n *                        <li key={post.id}>{post.title}</li>\n *                    ));\n *                })}\n *            </ul>\n *            <div>\n *                <button disabled={!hasNextPage} onClick={() => fetchNextPage()}>\n *                    Fetch next page\n *                </button>\n *            </div>\n *        </>\n *    );\n * };\n */\n\nexport const useInfiniteGetList = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: Partial<GetListParams> = {},\n    options?: UseInfiniteQueryOptions<GetInfiniteListResult<RecordType>, Error>\n): UseInfiniteGetListHookValue<RecordType> => {\n    const {\n        pagination = { page: 1, perPage: 25 },\n        sort = { field: 'id', order: 'DESC' },\n        filter = {},\n        meta,\n    } = params;\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n\n    const result = useInfiniteQuery<\n        GetInfiniteListResult<RecordType>,\n        Error,\n        GetInfiniteListResult<RecordType>\n    >(\n        [resource, 'getInfiniteList', { pagination, sort, filter, meta }],\n        ({ pageParam = pagination.page }) =>\n            dataProvider\n                .getList<RecordType>(resource, {\n                    pagination: {\n                        page: pageParam,\n                        perPage: pagination.perPage,\n                    },\n                    sort,\n                    filter,\n                    meta,\n                })\n                .then(({ data, pageInfo, total }) => ({\n                    data,\n                    total,\n                    pageParam,\n                    pageInfo,\n                })),\n        {\n            onSuccess: data => {\n                // optimistically populate the getOne cache\n                data.pages.forEach(page => {\n                    page.data.forEach(record => {\n                        queryClient.setQueryData(\n                            [\n                                resource,\n                                'getOne',\n                                { id: String(record.id), meta },\n                            ],\n                            oldRecord => oldRecord ?? record\n                        );\n                    });\n                });\n            },\n            ...options,\n            getNextPageParam: lastLoadedPage => {\n                if (lastLoadedPage.pageInfo) {\n                    return lastLoadedPage.pageInfo.hasNextPage\n                        ? lastLoadedPage.pageParam + 1\n                        : undefined;\n                }\n                const totalPages = Math.ceil(\n                    (lastLoadedPage.total || 0) / pagination.perPage\n                );\n\n                return lastLoadedPage.pageParam < totalPages\n                    ? Number(lastLoadedPage.pageParam) + 1\n                    : undefined;\n            },\n            getPreviousPageParam: lastLoadedPage => {\n                if (lastLoadedPage.pageInfo) {\n                    return lastLoadedPage.pageInfo.hasPreviousPage\n                        ? lastLoadedPage.pageParam - 1\n                        : undefined;\n                }\n\n                return lastLoadedPage.pageParam === 1\n                    ? undefined\n                    : lastLoadedPage.pageParam - 1;\n            },\n        }\n    );\n\n    return (result.data\n        ? {\n              ...result,\n              data: result.data,\n              total: result.data?.pages[0]?.total || undefined,\n          }\n        : result) as UseInfiniteQueryResult<\n        GetInfiniteListResult<RecordType>,\n        Error\n    > & {\n        total?: number;\n    };\n};\n\nexport type UseInfiniteGetListHookValue<\n    RecordType extends RaRecord = any\n> = UseInfiniteQueryResult<GetInfiniteListResult<RecordType>, Error> & {\n    total?: number;\n    pageParam?: number;\n};\n"]},"metadata":{},"sourceType":"module"}