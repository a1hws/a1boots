{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport HttpError from './HttpError';\nimport { stringify } from 'query-string';\nexport var createHeadersFromOptions = function (options) {\n  var requestHeaders = options.headers || new Headers({\n    Accept: 'application/json'\n  });\n\n  if (!requestHeaders.has('Content-Type') && !(options && (!options.method || options.method === 'GET')) && !(options && options.body && options.body instanceof FormData)) {\n    requestHeaders.set('Content-Type', 'application/json');\n  }\n\n  if (options.user && options.user.authenticated && options.user.token) {\n    requestHeaders.set('Authorization', options.user.token);\n  }\n\n  return requestHeaders;\n};\n/**\n * Utility function to make HTTP calls. It's similar to the HTML5 `fetch()`, except it handles JSON decoding and HTTP error codes automatically.\n *\n * @param url the URL to call\n * @param options the options to pass to the HTTP call\n * @param options.user the user object, used for the Authorization header\n * @param options.user.token the token to pass as the Authorization header\n * @param options.user.authenticated whether the user is authenticated or not (the Authorization header will be set only if this is true)\n * @param options.headers the headers to pass to the HTTP call\n *\n * @returns {Promise} the Promise for a response object containing the following properties:\n * - status: the HTTP status code\n * - headers: the HTTP headers\n * - body: the response body\n * - json: the response body parsed as JSON\n */\n\nexport var fetchJson = function (url, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var requestHeaders = createHeadersFromOptions(options);\n  return fetch(url, __assign(__assign({}, options), {\n    headers: requestHeaders\n  })).then(function (response) {\n    return response.text().then(function (text) {\n      return {\n        status: response.status,\n        statusText: response.statusText,\n        headers: response.headers,\n        body: text\n      };\n    });\n  }).then(function (_a) {\n    var status = _a.status,\n        statusText = _a.statusText,\n        headers = _a.headers,\n        body = _a.body;\n    var json;\n\n    try {\n      json = JSON.parse(body);\n    } catch (e) {// not json, no big deal\n    }\n\n    if (status < 200 || status >= 300) {\n      return Promise.reject(new HttpError(json && json.message || statusText, status, json));\n    }\n\n    return Promise.resolve({\n      status: status,\n      headers: headers,\n      body: body,\n      json: json\n    });\n  });\n};\nexport var queryParameters = stringify;\n\nvar isValidObject = function (value) {\n  if (!value) {\n    return false;\n  }\n\n  var isArray = Array.isArray(value);\n  var isBuffer = typeof Buffer !== 'undefined' && Buffer.isBuffer(value);\n  var isObject = Object.prototype.toString.call(value) === '[object Object]';\n  var hasKeys = !!Object.keys(value).length;\n  return !isArray && !isBuffer && isObject && hasKeys;\n};\n\nexport var flattenObject = function (value, path) {\n  var _a;\n\n  if (path === void 0) {\n    path = [];\n  }\n\n  if (isValidObject(value)) {\n    return Object.assign.apply(Object, __spreadArray([{}], Object.keys(value).map(function (key) {\n      return flattenObject(value[key], path.concat([key]));\n    }), false));\n  } else {\n    return path.length ? (_a = {}, _a[path.join('.')] = value, _a) : value;\n  }\n};","map":{"version":3,"mappings":"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","names":["HttpError","stringify","createHeadersFromOptions","options","requestHeaders","headers","Headers","Accept","has","method","body","FormData","set","user","authenticated","token","fetchJson","url","fetch","__assign","then","text","status","response","statusText","_a","json","JSON","parse","e","Promise","reject","message","resolve","queryParameters","isValidObject","value","isArray","Array","isBuffer","Buffer","isObject","Object","prototype","toString","call","hasKeys","keys","length","flattenObject","path","assign","apply","__spreadArray","map","key","concat","join"],"sources":["/var/www/a1boots/node_modules/ra-core/src/dataProvider/fetch.ts"],"sourcesContent":["import HttpError from './HttpError';\nimport { stringify } from 'query-string';\n\nexport interface Options extends RequestInit {\n    user?: {\n        authenticated?: boolean;\n        token?: string;\n    };\n}\n\nexport const createHeadersFromOptions = (options: Options): Headers => {\n    const requestHeaders = (options.headers ||\n        new Headers({\n            Accept: 'application/json',\n        })) as Headers;\n    if (\n        !requestHeaders.has('Content-Type') &&\n        !(options && (!options.method || options.method === 'GET')) &&\n        !(options && options.body && options.body instanceof FormData)\n    ) {\n        requestHeaders.set('Content-Type', 'application/json');\n    }\n    if (options.user && options.user.authenticated && options.user.token) {\n        requestHeaders.set('Authorization', options.user.token);\n    }\n\n    return requestHeaders;\n};\n\n/**\n * Utility function to make HTTP calls. It's similar to the HTML5 `fetch()`, except it handles JSON decoding and HTTP error codes automatically.\n *\n * @param url the URL to call\n * @param options the options to pass to the HTTP call\n * @param options.user the user object, used for the Authorization header\n * @param options.user.token the token to pass as the Authorization header\n * @param options.user.authenticated whether the user is authenticated or not (the Authorization header will be set only if this is true)\n * @param options.headers the headers to pass to the HTTP call\n *\n * @returns {Promise} the Promise for a response object containing the following properties:\n * - status: the HTTP status code\n * - headers: the HTTP headers\n * - body: the response body\n * - json: the response body parsed as JSON\n */\nexport const fetchJson = (url, options: Options = {}) => {\n    const requestHeaders = createHeadersFromOptions(options);\n\n    return fetch(url, { ...options, headers: requestHeaders })\n        .then(response =>\n            response.text().then(text => ({\n                status: response.status,\n                statusText: response.statusText,\n                headers: response.headers,\n                body: text,\n            }))\n        )\n        .then(({ status, statusText, headers, body }) => {\n            let json;\n            try {\n                json = JSON.parse(body);\n            } catch (e) {\n                // not json, no big deal\n            }\n            if (status < 200 || status >= 300) {\n                return Promise.reject(\n                    new HttpError(\n                        (json && json.message) || statusText,\n                        status,\n                        json\n                    )\n                );\n            }\n            return Promise.resolve({ status, headers, body, json });\n        });\n};\n\nexport const queryParameters = stringify;\n\nconst isValidObject = value => {\n    if (!value) {\n        return false;\n    }\n\n    const isArray = Array.isArray(value);\n    const isBuffer = typeof Buffer !== 'undefined' && Buffer.isBuffer(value);\n    const isObject =\n        Object.prototype.toString.call(value) === '[object Object]';\n    const hasKeys = !!Object.keys(value).length;\n\n    return !isArray && !isBuffer && isObject && hasKeys;\n};\n\nexport const flattenObject = (value, path = []) => {\n    if (isValidObject(value)) {\n        return Object.assign(\n            {},\n            ...Object.keys(value).map(key =>\n                flattenObject(value[key], path.concat([key]))\n            )\n        );\n    } else {\n        return path.length ? { [path.join('.')]: value } : value;\n    }\n};\n"]},"metadata":{},"sourceType":"module"}