{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { useCallback, useMemo, useRef } from 'react';\n/**\n * Internal hook used to handle mutation middlewares.\n *\n * @example\n * // We have a form creating an order for a new customer.\n * // The form contains the customer fields in addition to the order fields\n * // but they should be saved as a new customer resource record\n * // and the order should only reference this new customer\n * type Order = { id: string; reference: string };\n * type OrderCreateFormData = { id: string; reference: string; customer: Customer };\n * type Customer = { id: string; email: string; firstName: string; lastName: string };\n *\n * const CustomerForm = props => {\n *     const [createCustomer] = useCreate<Customer>();\n *     const middleware: Middleware<UseCreateResult<OrderCreateFormData>[0]> = useCallback(async (resource, params, options, next) => {\n *         const { data } = params;\n *         const { user, ...orderData } = data;\n *         await createCustomer(\n *             'customers',\n *             { data: user },\n *             {\n *                 onSuccess: (newCustomer) => {\n *                     const orderDataWithCustomer = { ...orderData, customerId: newCustomer.id };\n *                     next(resource, { data: orderDataWithCustomer }, options);\n *                 },\n *             }\n *         });\n *     }, [createCustomer]);\n *     useRegisterMutationMiddleware(middleware);\n *\n *     return (\n *         <>\n *             <TextInput source=\"user.email\" />\n *             <TextInput source=\"user.firstName\" />\n *             <TextInput source=\"user.lastName\" />\n *         </>\n *     );\n * }\n */\n\nexport var useMutationMiddlewares = function () {\n  var callbacks = useRef([]);\n  var registerMutationMiddleware = useCallback(function (callback) {\n    callbacks.current.push(callback);\n  }, []);\n  var unregisterMutationMiddleware = useCallback(function (callback) {\n    callbacks.current = callbacks.current.filter(function (cb) {\n      return cb !== callback;\n    });\n  }, []);\n  var getMutateWithMiddlewares = useCallback(function (fn) {\n    return function () {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var index = callbacks.current.length - 1; // Called by middlewares to call the next middleware function\n      // Should take the same arguments as the original mutation function\n\n      var next = function () {\n        var _a;\n\n        var newArgs = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          newArgs[_i] = arguments[_i];\n        } // Decrement the middlewares counter so that when next is called again, we\n        // call the next middleware\n\n\n        index--; // If there are no more middlewares, we call the original mutation function\n\n        if (index >= 0) {\n          return (_a = callbacks.current)[index].apply(_a, __spreadArray(__spreadArray([], newArgs, false), [next], false));\n        } else {\n          return fn.apply(void 0, newArgs);\n        }\n      };\n\n      if (callbacks.current.length > 0) {\n        // Call the first middleware with the same args as the original mutation function\n        // with an additional next function\n        return (_a = callbacks.current)[index].apply(_a, __spreadArray(__spreadArray([], args, false), [next], false));\n      }\n\n      return fn.apply(void 0, args);\n    };\n  }, []);\n  var functions = useMemo(function () {\n    return {\n      registerMutationMiddleware: registerMutationMiddleware,\n      getMutateWithMiddlewares: getMutateWithMiddlewares,\n      unregisterMutationMiddleware: unregisterMutationMiddleware\n    };\n  }, [registerMutationMiddleware, getMutateWithMiddlewares, unregisterMutationMiddleware]);\n  return functions;\n};","map":{"version":3,"mappings":";;;;;;;;;;AAAA,SAASA,WAAT,EAAsBC,OAAtB,EAA+BC,MAA/B,QAA6C,OAA7C;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA,OAAO,IAAMC,sBAAsB,GAAG;EAGlC,IAAMC,SAAS,GAAGF,MAAM,CAA2B,EAA3B,CAAxB;EAEA,IAAMG,0BAA0B,GAAGL,WAAW,CAC1C,UAACM,QAAD,EAAiC;IAC7BF,SAAS,CAACG,OAAV,CAAkBC,IAAlB,CAAuBF,QAAvB;EACH,CAHyC,EAI1C,EAJ0C,CAA9C;EAOA,IAAMG,4BAA4B,GAAGT,WAAW,CAC5C,UAACM,QAAD,EAAiC;IAC7BF,SAAS,CAACG,OAAV,GAAoBH,SAAS,CAACG,OAAV,CAAkBG,MAAlB,CAAyB,cAAE;MAAI,SAAE,KAAKJ,QAAP;IAAe,CAA9C,CAApB;EACH,CAH2C,EAI5C,EAJ4C,CAAhD;EAOA,IAAMK,wBAAwB,GAAGX,WAAW,CAAC,UAACY,EAAD,EAAe;IACxD,OAAO;;;MAAC;;WAAA,yCAA+B;QAA/BC;;;MACJ,IAAIC,KAAK,GAAGV,SAAS,CAACG,OAAV,CAAkBQ,MAAlB,GAA2B,CAAvC,CADG,CAGH;MACA;;MACA,IAAMC,IAAI,GAAG;;;QAAC;;aAAA,yCAAe;UAAfC;SAAD,CACT;QACA;;;QACAH,KAAK,GAHI,CAKT;;QACA,IAAIA,KAAK,IAAI,CAAb,EAAgB;UACZ,OAAO,eAAS,CAACP,OAAV,EAAkBO,KAAlB,EAAwBI,KAAxB,CAAwBC,EAAxB,EAAwBC,gCAAIH,OAAJ,EAAW,KAAX,GAAW,CAAED,IAAF,CAAX,EAAiB,KAAjB,CAAxB,CAAP;QACH,CAFD,MAEO;UACH,OAAOJ,EAAE,MAAF,CAAE,MAAF,EAAMK,OAAN,CAAP;QACH;MACJ,CAXD;;MAaA,IAAIb,SAAS,CAACG,OAAV,CAAkBQ,MAAlB,GAA2B,CAA/B,EAAkC;QAC9B;QACA;QACA,OAAO,eAAS,CAACR,OAAV,EAAkBO,KAAlB,EAAwBI,KAAxB,CAAwBC,EAAxB,EAAwBC,gCAAIP,IAAJ,EAAQ,KAAR,GAAQ,CAAEG,IAAF,CAAR,EAAc,KAAd,CAAxB,CAAP;MACH;;MAED,OAAOJ,EAAE,MAAF,CAAE,MAAF,EAAMC,IAAN,CAAP;IACH,CAzBD;EA0BH,CA3B2C,EA2BzC,EA3ByC,CAA5C;EA6BA,IAAMQ,SAAS,GAAGpB,OAAO,CACrB;IAAM,OAAC;MACHI,0BAA0B,4BADvB;MAEHM,wBAAwB,0BAFrB;MAGHF,4BAA4B;IAHzB,CAAD;EAIJ,CALmB,EAMrB,CACIJ,0BADJ,EAEIM,wBAFJ,EAGIF,4BAHJ,CANqB,CAAzB;EAaA,OAAOY,SAAP;AACH,CA9DM","names":["useCallback","useMemo","useRef","useMutationMiddlewares","callbacks","registerMutationMiddleware","callback","current","push","unregisterMutationMiddleware","filter","getMutateWithMiddlewares","fn","args","index","length","next","newArgs","apply","_a","__spreadArray","functions"],"sources":["/var/www/a1boots/node_modules/ra-core/src/controller/saveContext/useMutationMiddlewares.ts"],"sourcesContent":["import { useCallback, useMemo, useRef } from 'react';\n\n/**\n * Internal hook used to handle mutation middlewares.\n *\n * @example\n * // We have a form creating an order for a new customer.\n * // The form contains the customer fields in addition to the order fields\n * // but they should be saved as a new customer resource record\n * // and the order should only reference this new customer\n * type Order = { id: string; reference: string };\n * type OrderCreateFormData = { id: string; reference: string; customer: Customer };\n * type Customer = { id: string; email: string; firstName: string; lastName: string };\n *\n * const CustomerForm = props => {\n *     const [createCustomer] = useCreate<Customer>();\n *     const middleware: Middleware<UseCreateResult<OrderCreateFormData>[0]> = useCallback(async (resource, params, options, next) => {\n *         const { data } = params;\n *         const { user, ...orderData } = data;\n *         await createCustomer(\n *             'customers',\n *             { data: user },\n *             {\n *                 onSuccess: (newCustomer) => {\n *                     const orderDataWithCustomer = { ...orderData, customerId: newCustomer.id };\n *                     next(resource, { data: orderDataWithCustomer }, options);\n *                 },\n *             }\n *         });\n *     }, [createCustomer]);\n *     useRegisterMutationMiddleware(middleware);\n *\n *     return (\n *         <>\n *             <TextInput source=\"user.email\" />\n *             <TextInput source=\"user.firstName\" />\n *             <TextInput source=\"user.lastName\" />\n *         </>\n *     );\n * }\n */\nexport const useMutationMiddlewares = <\n    MutateFunc extends (...args: any[]) => any = (...args: any[]) => any\n>(): UseMutationMiddlewaresResult<MutateFunc> => {\n    const callbacks = useRef<Middleware<MutateFunc>[]>([]);\n\n    const registerMutationMiddleware = useCallback(\n        (callback: Middleware<MutateFunc>) => {\n            callbacks.current.push(callback);\n        },\n        []\n    );\n\n    const unregisterMutationMiddleware = useCallback(\n        (callback: Middleware<MutateFunc>) => {\n            callbacks.current = callbacks.current.filter(cb => cb !== callback);\n        },\n        []\n    );\n\n    const getMutateWithMiddlewares = useCallback((fn: MutateFunc) => {\n        return (...args: Parameters<MutateFunc>): ReturnType<MutateFunc> => {\n            let index = callbacks.current.length - 1;\n\n            // Called by middlewares to call the next middleware function\n            // Should take the same arguments as the original mutation function\n            const next = (...newArgs: any) => {\n                // Decrement the middlewares counter so that when next is called again, we\n                // call the next middleware\n                index--;\n\n                // If there are no more middlewares, we call the original mutation function\n                if (index >= 0) {\n                    return callbacks.current[index](...newArgs, next);\n                } else {\n                    return fn(...newArgs);\n                }\n            };\n\n            if (callbacks.current.length > 0) {\n                // Call the first middleware with the same args as the original mutation function\n                // with an additional next function\n                return callbacks.current[index](...args, next);\n            }\n\n            return fn(...args);\n        };\n    }, []);\n\n    const functions = useMemo<UseMutationMiddlewaresResult<MutateFunc>>(\n        () => ({\n            registerMutationMiddleware,\n            getMutateWithMiddlewares,\n            unregisterMutationMiddleware,\n        }),\n        [\n            registerMutationMiddleware,\n            getMutateWithMiddlewares,\n            unregisterMutationMiddleware,\n        ]\n    );\n\n    return functions;\n};\n\nexport interface UseMutationMiddlewaresResult<\n    MutateFunc extends (...args: any[]) => any = (...args: any[]) => any\n> {\n    registerMutationMiddleware: (callback: Middleware<MutateFunc>) => void;\n    getMutateWithMiddlewares: (\n        mutate: MutateFunc\n    ) => (...args: Parameters<MutateFunc>) => ReturnType<MutateFunc>;\n    unregisterMutationMiddleware: (callback: Middleware<MutateFunc>) => void;\n}\n\nexport type Middleware<MutateFunc> = MutateFunc extends (...a: any[]) => infer R\n    ? (...a: [...U: Parameters<MutateFunc>, next: MutateFunc]) => R\n    : never;\n"]},"metadata":{},"sourceType":"module"}