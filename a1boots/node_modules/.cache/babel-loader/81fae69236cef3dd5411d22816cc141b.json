{"ast":null,"code":"import { useQuery } from 'react-query';\nimport { useDataProvider } from './useDataProvider';\n/**\n * Call the dataProvider.getOne() method and return the resolved value\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, isFetching: true, refetch }\n * - success: { data: [data from response], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getOne parameters { id, meta }, e.g. { id: 123 }\n * @param {Options} options Options object to pass to the react-query queryClient.\n *\n * @typedef Params\n * @prop id a resource identifier, e.g. 123\n *\n * @typedef Options\n * @prop enabled Flag to conditionally run the query. If it's false, the query will not run\n * @prop onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @prop onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetOne, useRecordContext } from 'react-admin';\n *\n * const UserProfile = () => {\n *     const record = useRecordContext();\n *     const { data, isLoading, error } = useGetOne('users', { id: record.id });\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <div>User {data.username}</div>;\n * };\n */\n\nexport var useGetOne = function useGetOne(resource, _a, options) {\n  var id = _a.id,\n      meta = _a.meta;\n  var dataProvider = useDataProvider();\n  return useQuery( // Sometimes the id comes as a string (e.g. when read from the URL in a Show view).\n  // Sometimes the id comes as a number (e.g. when read from a Record in useGetList response).\n  // As the react-query cache is type-sensitive, we always stringify the identifier to get a match\n  [resource, 'getOne', {\n    id: String(id),\n    meta: meta\n  }], function () {\n    return dataProvider.getOne(resource, {\n      id: id,\n      meta: meta\n    }).then(function (_a) {\n      var data = _a.data;\n      return data;\n    });\n  }, options);\n};","map":{"version":3,"mappings":"AACA,SAASA,QAAT,QAA0D,aAA1D;AACA,SAASC,eAAT,QAAgC,mBAAhC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA,OAAO,IAAMC,SAAS,GAAG,SAAZA,SAAY,CACrBC,QADqB,EAErBC,EAFqB,EAGrBC,OAHqB,EAGgB;MADnCC,EAAE;MAAEC,IAAI;EAGV,IAAMC,YAAY,GAAGP,eAAe,EAApC;EACA,OAAOD,QAAQ,EACX;EACA;EACA;EACA,CAACG,QAAD,EAAW,QAAX,EAAqB;IAAEG,EAAE,EAAEG,MAAM,CAACH,EAAD,CAAZ;IAAkBC,IAAI;EAAtB,CAArB,CAJW,EAKX;IACI,mBAAY,CACPG,MADL,CACwBP,QADxB,EACkC;MAAEG,EAAE,IAAJ;MAAMC,IAAI;IAAV,CADlC,EAEKI,IAFL,CAEU,UAACP,EAAD,EAAS;UAANQ,IAAI;MAAO;IAAI,CAF5B;EAE6B,CARtB,EASXP,OATW,CAAf;AAWH,CAjBM","names":["useQuery","useDataProvider","useGetOne","resource","_a","options","id","meta","dataProvider","String","getOne","then","data"],"sources":["/var/www/a1boots/node_modules/ra-core/src/dataProvider/useGetOne.ts"],"sourcesContent":["import { RaRecord, GetOneParams } from '../types';\nimport { useQuery, UseQueryOptions, UseQueryResult } from 'react-query';\nimport { useDataProvider } from './useDataProvider';\n\n/**\n * Call the dataProvider.getOne() method and return the resolved value\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, isFetching: true, refetch }\n * - success: { data: [data from response], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getOne parameters { id, meta }, e.g. { id: 123 }\n * @param {Options} options Options object to pass to the react-query queryClient.\n *\n * @typedef Params\n * @prop id a resource identifier, e.g. 123\n *\n * @typedef Options\n * @prop enabled Flag to conditionally run the query. If it's false, the query will not run\n * @prop onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @prop onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetOne, useRecordContext } from 'react-admin';\n *\n * const UserProfile = () => {\n *     const record = useRecordContext();\n *     const { data, isLoading, error } = useGetOne('users', { id: record.id });\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <div>User {data.username}</div>;\n * };\n */\nexport const useGetOne = <RecordType extends RaRecord = any>(\n    resource: string,\n    { id, meta }: GetOneParams<RecordType>,\n    options?: UseQueryOptions<RecordType>\n): UseGetOneHookValue<RecordType> => {\n    const dataProvider = useDataProvider();\n    return useQuery<RecordType, unknown, RecordType>(\n        // Sometimes the id comes as a string (e.g. when read from the URL in a Show view).\n        // Sometimes the id comes as a number (e.g. when read from a Record in useGetList response).\n        // As the react-query cache is type-sensitive, we always stringify the identifier to get a match\n        [resource, 'getOne', { id: String(id), meta }],\n        () =>\n            dataProvider\n                .getOne<RecordType>(resource, { id, meta })\n                .then(({ data }) => data),\n        options\n    );\n};\n\nexport type UseGetOneHookValue<\n    RecordType extends RaRecord = any\n> = UseQueryResult<RecordType>;\n"]},"metadata":{},"sourceType":"module"}