{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { useMemo } from 'react';\nimport { useQuery, useQueryClient } from 'react-query';\nimport { useDataProvider } from './useDataProvider';\n/**\n * Call the dataProvider.getManyReference() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, refetch }\n * - success: { data: [data from store], total: [total from response], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getManyReference parameters { target, id, pagination, sort, filter, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.target The target resource key, e.g. 'post_id'\n * @prop params.id The identifier of the record to look for in target, e.g. '123'\n * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }\n * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }\n * @prop params.filter The request filters, e.g. { title: 'hello, world' }\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, total, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetManyReference, useRecordContext } from 'react-admin';\n *\n * const PostComments = () => {\n *     const record = useRecordContext();\n *     // fetch all comments related to the current record\n *     const { data, isLoading, error } = useGetManyReference(\n *         'comments',\n *         { target: 'post_id', id: record.id, pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(comment =>\n *         <li key={comment.id}>{comment.body}</li>\n *     )}</ul>;\n * };\n */\n\nexport var useGetManyReference = function useGetManyReference(resource, params, options) {\n  if (params === void 0) {\n    params = {};\n  }\n\n  var target = params.target,\n      id = params.id,\n      _a = params.pagination,\n      pagination = _a === void 0 ? {\n    page: 1,\n    perPage: 25\n  } : _a,\n      _b = params.sort,\n      sort = _b === void 0 ? {\n    field: 'id',\n    order: 'DESC'\n  } : _b,\n      _c = params.filter,\n      filter = _c === void 0 ? {} : _c,\n      meta = params.meta;\n  var dataProvider = useDataProvider();\n  var queryClient = useQueryClient();\n  var result = useQuery([resource, 'getManyReference', {\n    target: target,\n    id: id,\n    pagination: pagination,\n    sort: sort,\n    filter: filter,\n    meta: meta\n  }], function () {\n    if (!target || id == null) {\n      // check at runtime to support partial parameters with the enabled option\n      return Promise.reject(new Error('target and id are required'));\n    }\n\n    return dataProvider.getManyReference(resource, {\n      target: target,\n      id: id,\n      pagination: pagination,\n      sort: sort,\n      filter: filter,\n      meta: meta\n    }).then(function (_a) {\n      var data = _a.data,\n          total = _a.total,\n          pageInfo = _a.pageInfo;\n      return {\n        data: data,\n        total: total,\n        pageInfo: pageInfo\n      };\n    });\n  }, __assign({\n    onSuccess: function onSuccess(_a) {\n      var data = _a.data; // optimistically populate the getOne cache\n\n      data.forEach(function (record) {\n        queryClient.setQueryData([resource, 'getOne', {\n          id: String(record.id),\n          meta: meta\n        }], function (oldRecord) {\n          return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;\n        });\n      });\n    }\n  }, options));\n  return useMemo(function () {\n    var _a, _b, _c;\n\n    return result.data ? __assign(__assign({}, result), {\n      data: (_a = result.data) === null || _a === void 0 ? void 0 : _a.data,\n      total: (_b = result.data) === null || _b === void 0 ? void 0 : _b.total,\n      pageInfo: (_c = result.data) === null || _c === void 0 ? void 0 : _c.pageInfo\n    }) : result;\n  }, [result]);\n};","map":{"version":3,"mappings":"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","names":["useMemo","useQuery","useQueryClient","useDataProvider","useGetManyReference","resource","params","options","id","_a","pagination","page","perPage","_b","sort","field","order","_c","filter","meta","dataProvider","queryClient","result","target","Promise","reject","Error","getManyReference","then","data","total","pageInfo","__assign","onSuccess","forEach","setQueryData","String","record"],"sources":["/var/www/a1boots/node_modules/ra-core/src/dataProvider/useGetManyReference.ts"],"sourcesContent":["import { useMemo } from 'react';\nimport {\n    useQuery,\n    UseQueryOptions,\n    UseQueryResult,\n    useQueryClient,\n} from 'react-query';\n\nimport {\n    RaRecord,\n    GetManyReferenceParams,\n    GetManyReferenceResult,\n} from '../types';\nimport { useDataProvider } from './useDataProvider';\n\n/**\n * Call the dataProvider.getManyReference() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, refetch }\n * - success: { data: [data from store], total: [total from response], isLoading: false, refetch }\n * - error: { error: [error from response], isLoading: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param {string} resource The resource name, e.g. 'posts'\n * @param {Params} params The getManyReference parameters { target, id, pagination, sort, filter, meta }\n * @param {Object} options Options object to pass to the queryClient.\n * May include side effects to be executed upon success or failure, e.g. { onSuccess: () => { refresh(); } }\n *\n * @typedef Params\n * @prop params.target The target resource key, e.g. 'post_id'\n * @prop params.id The identifier of the record to look for in target, e.g. '123'\n * @prop params.pagination The request pagination { page, perPage }, e.g. { page: 1, perPage: 10 }\n * @prop params.sort The request sort { field, order }, e.g. { field: 'id', order: 'DESC' }\n * @prop params.filter The request filters, e.g. { title: 'hello, world' }\n * @prop params.meta Optional meta parameters\n *\n * @returns The current request state. Destructure as { data, total, error, isLoading, refetch }.\n *\n * @example\n *\n * import { useGetManyReference, useRecordContext } from 'react-admin';\n *\n * const PostComments = () => {\n *     const record = useRecordContext();\n *     // fetch all comments related to the current record\n *     const { data, isLoading, error } = useGetManyReference(\n *         'comments',\n *         { target: 'post_id', id: record.id, pagination: { page: 1, perPage: 10 }, sort: { field: 'published_at', order: 'DESC' } }\n *     );\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <ul>{data.map(comment =>\n *         <li key={comment.id}>{comment.body}</li>\n *     )}</ul>;\n * };\n */\nexport const useGetManyReference = <RecordType extends RaRecord = any>(\n    resource: string,\n    params: Partial<GetManyReferenceParams> = {},\n    options?: UseQueryOptions<{ data: RecordType[]; total: number }, Error>\n): UseGetManyReferenceHookValue<RecordType> => {\n    const {\n        target,\n        id,\n        pagination = { page: 1, perPage: 25 },\n        sort = { field: 'id', order: 'DESC' },\n        filter = {},\n        meta,\n    } = params;\n    const dataProvider = useDataProvider();\n    const queryClient = useQueryClient();\n    const result = useQuery<\n        GetManyReferenceResult<RecordType>,\n        Error,\n        GetManyReferenceResult<RecordType>\n    >(\n        [\n            resource,\n            'getManyReference',\n            { target, id, pagination, sort, filter, meta },\n        ],\n        () => {\n            if (!target || id == null) {\n                // check at runtime to support partial parameters with the enabled option\n                return Promise.reject(new Error('target and id are required'));\n            }\n            return dataProvider\n                .getManyReference<RecordType>(resource, {\n                    target,\n                    id,\n                    pagination,\n                    sort,\n                    filter,\n                    meta,\n                })\n                .then(({ data, total, pageInfo }) => ({\n                    data,\n                    total,\n                    pageInfo,\n                }));\n        },\n        {\n            onSuccess: ({ data }) => {\n                // optimistically populate the getOne cache\n                data.forEach(record => {\n                    queryClient.setQueryData(\n                        [resource, 'getOne', { id: String(record.id), meta }],\n                        oldRecord => oldRecord ?? record\n                    );\n                });\n            },\n            ...options,\n        }\n    );\n\n    return useMemo(\n        () =>\n            result.data\n                ? {\n                      ...result,\n                      data: result.data?.data,\n                      total: result.data?.total,\n                      pageInfo: result.data?.pageInfo,\n                  }\n                : result,\n        [result]\n    ) as UseQueryResult<RecordType[], Error> & {\n        total?: number;\n        pageInfo?: {\n            hasNextPage?: boolean;\n            hasPreviousPage?: boolean;\n        };\n    };\n};\n\nexport type UseGetManyReferenceHookValue<\n    RecordType extends RaRecord = any\n> = UseQueryResult<RecordType[], Error> & {\n    total?: number;\n    pageInfo?: {\n        hasNextPage?: boolean;\n        hasPreviousPage?: boolean;\n    };\n};\n"]},"metadata":{},"sourceType":"module"}