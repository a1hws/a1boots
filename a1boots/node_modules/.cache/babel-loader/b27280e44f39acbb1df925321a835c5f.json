{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport * as React from 'react';\nimport { isValidElement, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport debounce from 'lodash/debounce';\nimport get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport clsx from 'clsx';\nimport { Autocomplete, Chip, TextField, createFilterOptions } from '@mui/material';\nimport { styled } from '@mui/material/styles';\nimport { FieldTitle, useChoicesContext, useInput, useSuggestions, useTimeout, useTranslate, warning, useGetRecordRepresentation } from 'ra-core';\nimport { useSupportCreateSuggestion } from './useSupportCreateSuggestion';\nimport { InputHelperText } from './InputHelperText';\nimport { sanitizeInputRestProps } from './sanitizeInputRestProps';\nvar defaultFilterOptions = createFilterOptions();\n/**\n * An Input component for an autocomplete field, using an array of objects for the options\n *\n * Pass possible options as an array of objects in the 'choices' attribute.\n *\n * By default, the options are built from:\n *  - the 'id' property as the option value,\n *  - the 'name' property as the option text\n * @example\n * const choices = [\n *    { id: 'M', name: 'Male' },\n *    { id: 'F', name: 'Female' },\n * ];\n * <AutocompleteInput source=\"gender\" choices={choices} />\n *\n * You can also customize the properties to use for the option name and value,\n * thanks to the 'optionText' and 'optionValue' attributes.\n * @example\n * const choices = [\n *    { _id: 123, full_name: 'Leo Tolstoi', sex: 'M' },\n *    { _id: 456, full_name: 'Jane Austen', sex: 'F' },\n * ];\n * <AutocompleteInput source=\"author_id\" choices={choices} optionText=\"full_name\" optionValue=\"_id\" />\n *\n * `optionText` also accepts a function, so you can shape the option text at will:\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;\n * <AutocompleteInput source=\"author_id\" choices={choices} optionText={optionRenderer} />\n *\n * `optionText` also accepts a React Element, that can access\n * the related choice through the `useRecordContext` hook. You can use Field components there.\n * Note that you must also specify the `matchSuggestion` and `inputText` props\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const matchSuggestion = (filterValue, choice) => choice.first_name.match(filterValue) || choice.last_name.match(filterValue)\n * const inputText = (record) => `${record.fullName} (${record.language})`;\n *\n * const FullNameField = () => {\n *     const record = useRecordContext();\n *     return <span>{record.first_name} {record.last_name}</span>;\n * }\n * <AutocompleteInput source=\"author\" choices={choices} optionText={<FullNameField />} matchSuggestion={matchSuggestion} inputText={inputText} />\n *\n * The choices are translated by default, so you can use translation identifiers as choices:\n * @example\n * const choices = [\n *    { id: 'M', name: 'myroot.gender.male' },\n *    { id: 'F', name: 'myroot.gender.female' },\n * ];\n *\n * However, in some cases (e.g. inside a `<ReferenceInput>`), you may not want\n * the choice to be translated. In that case, set the `translateChoice` prop to false.\n * @example\n * <AutocompleteInput source=\"gender\" choices={choices} translateChoice={false}/>\n *\n * The object passed as `options` props is passed to the Material UI <TextField> component\n *\n * @example\n * <AutocompleteInput source=\"author_id\" options={{ color: 'secondary', InputLabelProps: { shrink: true } }} />\n */\n\nexport var AutocompleteInput = function (props) {\n  var choicesProp = props.choices,\n      className = props.className,\n      _a = props.clearOnBlur,\n      clearOnBlur = _a === void 0 ? true : _a,\n      _b = props.clearText,\n      clearText = _b === void 0 ? 'ra.action.clear_input_value' : _b,\n      _c = props.closeText,\n      closeText = _c === void 0 ? 'ra.action.close' : _c,\n      create = props.create,\n      createLabel = props.createLabel,\n      createItemLabel = props.createItemLabel,\n      createValue = props.createValue,\n      _d = props.debounce,\n      debounceDelay = _d === void 0 ? 250 : _d,\n      defaultValue = props.defaultValue,\n      emptyText = props.emptyText,\n      _e = props.emptyValue,\n      emptyValue = _e === void 0 ? '' : _e,\n      fieldOverride = props.field,\n      format = props.format,\n      helperText = props.helperText,\n      idOverride = props.id,\n      inputText = props.inputText,\n      isFetchingProp = props.isFetching,\n      isLoadingProp = props.isLoading,\n      isRequiredOverride = props.isRequired,\n      label = props.label,\n      limitChoicesToValue = props.limitChoicesToValue,\n      matchSuggestion = props.matchSuggestion,\n      margin = props.margin,\n      fieldStateOverride = props.fieldState,\n      _f = props.filterToQuery,\n      filterToQuery = _f === void 0 ? DefaultFilterToQuery : _f,\n      formStateOverride = props.formState,\n      _g = props.multiple,\n      multiple = _g === void 0 ? false : _g,\n      noOptionsText = props.noOptionsText,\n      onBlur = props.onBlur,\n      onChange = props.onChange,\n      onCreate = props.onCreate,\n      _h = props.openText,\n      openText = _h === void 0 ? 'ra.action.open' : _h,\n      optionText = props.optionText,\n      optionValue = props.optionValue,\n      parse = props.parse,\n      resourceProp = props.resource,\n      shouldRenderSuggestions = props.shouldRenderSuggestions,\n      setFilter = props.setFilter,\n      size = props.size,\n      sourceProp = props.source,\n      _j = props.suggestionLimit,\n      suggestionLimit = _j === void 0 ? Infinity : _j,\n      TextFieldProps = props.TextFieldProps,\n      translateChoice = props.translateChoice,\n      validate = props.validate,\n      variant = props.variant,\n      rest = __rest(props, [\"choices\", \"className\", \"clearOnBlur\", \"clearText\", \"closeText\", \"create\", \"createLabel\", \"createItemLabel\", \"createValue\", \"debounce\", \"defaultValue\", \"emptyText\", \"emptyValue\", \"field\", \"format\", \"helperText\", \"id\", \"inputText\", \"isFetching\", \"isLoading\", \"isRequired\", \"label\", \"limitChoicesToValue\", \"matchSuggestion\", \"margin\", \"fieldState\", \"filterToQuery\", \"formState\", \"multiple\", \"noOptionsText\", \"onBlur\", \"onChange\", \"onCreate\", \"openText\", \"optionText\", \"optionValue\", \"parse\", \"resource\", \"shouldRenderSuggestions\", \"setFilter\", \"size\", \"source\", \"suggestionLimit\", \"TextFieldProps\", \"translateChoice\", \"validate\", \"variant\"]);\n\n  var _k = useChoicesContext({\n    choices: choicesProp,\n    isFetching: isFetchingProp,\n    isLoading: isLoadingProp,\n    resource: resourceProp,\n    source: sourceProp\n  }),\n      allChoices = _k.allChoices,\n      isLoading = _k.isLoading,\n      fetchError = _k.error,\n      resource = _k.resource,\n      source = _k.source,\n      setFilters = _k.setFilters,\n      isFromReference = _k.isFromReference;\n\n  var translate = useTranslate();\n\n  var _l = useInput(__assign({\n    defaultValue: defaultValue,\n    id: idOverride,\n    field: fieldOverride,\n    fieldState: fieldStateOverride,\n    formState: formStateOverride,\n    isRequired: isRequiredOverride,\n    onBlur: onBlur,\n    onChange: onChange,\n    parse: parse,\n    format: format,\n    resource: resource,\n    source: source,\n    validate: validate\n  }, rest)),\n      id = _l.id,\n      field = _l.field,\n      isRequired = _l.isRequired,\n      _m = _l.fieldState,\n      error = _m.error,\n      invalid = _m.invalid,\n      isTouched = _m.isTouched,\n      isSubmitted = _l.formState.isSubmitted;\n\n  var finalChoices = useMemo(function () {\n    var _a; // eslint-disable-next-line eqeqeq\n\n\n    return emptyText == undefined || isRequired || multiple ? allChoices : [(_a = {}, _a[optionValue || 'id'] = emptyValue, _a[typeof optionText === 'string' ? optionText : 'name'] = translate(emptyText, {\n      _: emptyText\n    }), _a)].concat(allChoices);\n  }, [allChoices, emptyValue, emptyText, isRequired, multiple, optionText, optionValue, translate]);\n  var selectedChoice = useSelectedChoice(field.value, {\n    choices: finalChoices,\n    // @ts-ignore\n    multiple: multiple,\n    optionValue: optionValue\n  });\n  useEffect(function () {\n    // eslint-disable-next-line eqeqeq\n    if (emptyValue == null) {\n      throw new Error(\"emptyValue being set to null or undefined is not supported. Use parse to turn the empty string into null.\");\n    }\n  }, [emptyValue]);\n  useEffect(function () {\n    // eslint-disable-next-line eqeqeq\n    if (isValidElement(optionText) && emptyText != undefined) {\n      throw new Error(\"optionText of type React element is not supported when setting emptyText\");\n    } // eslint-disable-next-line eqeqeq\n\n\n    if (isValidElement(optionText) && inputText == undefined) {\n      throw new Error(\"\\nIf you provided a React element for the optionText prop, you must also provide the inputText prop (used for the text input)\");\n    } // eslint-disable-next-line eqeqeq\n\n\n    if (isValidElement(optionText) && matchSuggestion == undefined) {\n      throw new Error(\"\\nIf you provided a React element for the optionText prop, you must also provide the matchSuggestion prop (used to match the user input with a choice)\");\n    }\n  }, [optionText, inputText, matchSuggestion, emptyText]);\n  useEffect(function () {\n    warning(\n    /* eslint-disable eqeqeq */\n    shouldRenderSuggestions != undefined && noOptionsText == undefined, \"When providing a shouldRenderSuggestions function, we recommend you also provide the noOptionsText prop and set it to a text explaining users why no options are displayed. It supports translation keys.\");\n    /* eslint-enable eqeqeq */\n  }, [shouldRenderSuggestions, noOptionsText]);\n  var getRecordRepresentation = useGetRecordRepresentation(resource);\n\n  var _o = useSuggestions({\n    choices: finalChoices,\n    limitChoicesToValue: limitChoicesToValue,\n    matchSuggestion: matchSuggestion,\n    optionText: optionText !== null && optionText !== void 0 ? optionText : isFromReference ? getRecordRepresentation : undefined,\n    optionValue: optionValue,\n    selectedItem: selectedChoice,\n    suggestionLimit: suggestionLimit,\n    translateChoice: translateChoice\n  }),\n      getChoiceText = _o.getChoiceText,\n      getChoiceValue = _o.getChoiceValue,\n      getSuggestions = _o.getSuggestions;\n\n  var _p = useState(''),\n      filterValue = _p[0],\n      setFilterValue = _p[1];\n\n  var handleChange = function (newValue) {\n    var _a, _b;\n\n    if (multiple) {\n      if (Array.isArray(newValue)) {\n        field.onChange(newValue.map(getChoiceValue));\n      } else {\n        field.onChange(__spreadArray(__spreadArray([], (_a = field.value) !== null && _a !== void 0 ? _a : [], true), [getChoiceValue(newValue)], false));\n      }\n    } else {\n      field.onChange((_b = getChoiceValue(newValue)) !== null && _b !== void 0 ? _b : emptyValue);\n    }\n  }; // eslint-disable-next-line\n\n\n  var debouncedSetFilter = useCallback(debounce(function (filter) {\n    if (setFilter) {\n      return setFilter(filter);\n    }\n\n    if (choicesProp) {\n      return;\n    }\n\n    setFilters(filterToQuery(filter), undefined, true);\n  }, debounceDelay), [debounceDelay, setFilters, setFilter]); // We must reset the filter every time the value changes to ensure we\n  // display at least some choices even if the input has a value.\n  // Otherwise, it would only display the currently selected one and the user\n  // would have to first clear the input before seeing any other choices\n\n  var currentValue = useRef(field.value);\n  useEffect(function () {\n    if (!isEqual(currentValue.current, field.value)) {\n      currentValue.current = field.value;\n      debouncedSetFilter('');\n    }\n  }, [field.value]); // eslint-disable-line\n\n  var _q = useSupportCreateSuggestion({\n    create: create,\n    createLabel: createLabel,\n    createItemLabel: createItemLabel,\n    createValue: createValue,\n    handleChange: handleChange,\n    filter: filterValue,\n    onCreate: onCreate,\n    optionText: optionText\n  }),\n      getCreateItem = _q.getCreateItem,\n      handleChangeWithCreateSupport = _q.handleChange,\n      createElement = _q.createElement,\n      createId = _q.createId;\n\n  var getOptionLabel = useCallback(function (option, isListItem) {\n    if (isListItem === void 0) {\n      isListItem = false;\n    } // eslint-disable-next-line eqeqeq\n\n\n    if (option == undefined) {\n      return '';\n    } // Value selected with enter, right from the input\n\n\n    if (typeof option === 'string') {\n      return option;\n    }\n\n    if ((option === null || option === void 0 ? void 0 : option.id) === createId) {\n      return get(option, typeof optionText === 'string' ? optionText : 'name');\n    }\n\n    if (!isListItem && option[optionValue || 'id'] === emptyValue) {\n      return get(option, typeof optionText === 'string' ? optionText : 'name');\n    }\n\n    if (!isListItem && inputText !== undefined) {\n      return inputText(option);\n    }\n\n    return getChoiceText(option);\n  }, [getChoiceText, inputText, createId, optionText, optionValue, emptyValue]);\n  var finalOnBlur = useCallback(function () {\n    if (clearOnBlur && !multiple) {\n      var optionLabel = getOptionLabel(selectedChoice);\n\n      if (!isEqual(optionLabel, filterValue)) {\n        setFilterValue(optionLabel);\n        debouncedSetFilter('');\n      }\n    }\n\n    field.onBlur();\n  }, [clearOnBlur, field, getOptionLabel, selectedChoice, filterValue, debouncedSetFilter, multiple]);\n  useEffect(function () {\n    if (!multiple) {\n      var optionLabel = getOptionLabel(selectedChoice);\n\n      if (typeof optionLabel === 'string') {\n        setFilterValue(optionLabel);\n      } else {\n        throw new Error('When optionText returns a React element, you must also provide the inputText prop');\n      }\n    }\n  }, [getOptionLabel, multiple, selectedChoice]);\n\n  var handleInputChange = function (event, newInputValue, reason) {\n    if ((event === null || event === void 0 ? void 0 : event.type) === 'change' || !doesQueryMatchSelection(newInputValue)) {\n      setFilterValue(newInputValue);\n      debouncedSetFilter(newInputValue);\n    }\n  };\n\n  var doesQueryMatchSelection = useCallback(function (filter) {\n    var selectedItemTexts;\n\n    if (multiple) {\n      selectedItemTexts = selectedChoice.map(function (item) {\n        return getOptionLabel(item);\n      });\n    } else {\n      selectedItemTexts = [getOptionLabel(selectedChoice)];\n    }\n\n    return selectedItemTexts.includes(filter);\n  }, [getOptionLabel, multiple, selectedChoice]);\n  var doesQueryMatchSuggestion = useCallback(function (filter) {\n    var hasOption = !!finalChoices ? finalChoices.some(function (choice) {\n      return getOptionLabel(choice) === filter;\n    }) : false;\n    return doesQueryMatchSelection(filter) || hasOption;\n  }, [finalChoices, getOptionLabel, doesQueryMatchSelection]);\n\n  var filterOptions = function (options, params) {\n    var filteredOptions = isFromReference || // When used inside a reference, AutocompleteInput shouldn't do the filtering as it's done by the reference input\n    matchSuggestion || // When using element as optionText (and matchSuggestion), options are filtered by getSuggestions, so they shouldn't be filtered here\n    limitChoicesToValue // When limiting choices to values (why? it's legacy!), options are also filtered by getSuggestions, so they shouldn't be filtered here\n    ? options : defaultFilterOptions(options, params); // Otherwise, we let Material UI's Autocomplete do the filtering\n    // add create option if necessary\n\n    var inputValue = params.inputValue;\n\n    if ((onCreate || create) && inputValue !== '' && !doesQueryMatchSuggestion(filterValue)) {\n      filteredOptions = filteredOptions.concat(getCreateItem(inputValue));\n    }\n\n    return filteredOptions;\n  };\n\n  var handleAutocompleteChange = function (event, newValue, reason) {\n    handleChangeWithCreateSupport(newValue != null ? newValue : emptyValue);\n  };\n\n  var oneSecondHasPassed = useTimeout(1000, filterValue);\n  var suggestions = useMemo(function () {\n    if (matchSuggestion || limitChoicesToValue) {\n      return getSuggestions(filterValue);\n    }\n\n    return (finalChoices === null || finalChoices === void 0 ? void 0 : finalChoices.slice(0, suggestionLimit)) || [];\n  }, [finalChoices, filterValue, getSuggestions, limitChoicesToValue, matchSuggestion, suggestionLimit]);\n\n  var isOptionEqualToValue = function (option, value) {\n    return String(getChoiceValue(option)) === String(getChoiceValue(value));\n  };\n\n  return React.createElement(React.Fragment, null, React.createElement(StyledAutocomplete, __assign({\n    blurOnSelect: true,\n    className: clsx('ra-input', \"ra-input-\".concat(source), className),\n    clearText: translate(clearText, {\n      _: clearText\n    }),\n    closeText: translate(closeText, {\n      _: closeText\n    }),\n    openOnFocus: true,\n    openText: translate(openText, {\n      _: openText\n    }),\n    id: id,\n    isOptionEqualToValue: isOptionEqualToValue,\n    filterSelectedOptions: true,\n    renderInput: function (params) {\n      return React.createElement(TextField, __assign({\n        name: field.name,\n        label: React.createElement(FieldTitle, {\n          label: label,\n          source: source,\n          resource: resourceProp,\n          isRequired: isRequired\n        }),\n        error: !!fetchError || (isTouched || isSubmitted) && invalid,\n        helperText: React.createElement(InputHelperText, {\n          touched: isTouched || isSubmitted || fetchError,\n          error: (error === null || error === void 0 ? void 0 : error.message) || (fetchError === null || fetchError === void 0 ? void 0 : fetchError.message),\n          helperText: helperText\n        }),\n        margin: margin,\n        variant: variant,\n        className: AutocompleteInputClasses.textField\n      }, TextFieldProps, params, {\n        size: size\n      }));\n    },\n    multiple: multiple,\n    renderTags: function (value, getTagProps) {\n      return value.map(function (option, index) {\n        return React.createElement(Chip, __assign({\n          label: isValidElement(optionText) ? inputText(option) : getChoiceText(option),\n          sx: {\n            '.MuiSvgIcon-root': {\n              // FIXME: Workaround to allow choices deletion\n              // Maybe related to storybook and mui using different versions of emotion\n              zIndex: 100\n            }\n          },\n          size: \"small\"\n        }, getTagProps({\n          index: index\n        })));\n      });\n    },\n    noOptionsText: typeof noOptionsText === 'string' ? translate(noOptionsText, {\n      _: noOptionsText\n    }) : noOptionsText,\n    selectOnFocus: true,\n    clearOnBlur: clearOnBlur\n  }, sanitizeInputRestProps(rest), {\n    freeSolo: !!create || !!onCreate,\n    handleHomeEndKeys: !!create || !!onCreate,\n    filterOptions: filterOptions,\n    options: shouldRenderSuggestions == undefined || // eslint-disable-line eqeqeq\n    shouldRenderSuggestions(filterValue) ? suggestions : [],\n    getOptionLabel: getOptionLabel,\n    inputValue: filterValue,\n    loading: isLoading && (!finalChoices || finalChoices.length === 0) && oneSecondHasPassed,\n    value: selectedChoice,\n    onChange: handleAutocompleteChange,\n    onBlur: finalOnBlur,\n    onInputChange: handleInputChange,\n    renderOption: function (props, record) {\n      props.key = getChoiceValue(record);\n      var optionLabel = getOptionLabel(record, true);\n      return React.createElement(\"li\", __assign({}, props), optionLabel === '' ? ' ' : optionLabel);\n    }\n  })), createElement);\n};\nvar PREFIX = 'RaAutocompleteInput';\nexport var AutocompleteInputClasses = {\n  textField: \"\".concat(PREFIX, \"-textField\")\n};\nvar StyledAutocomplete = styled(Autocomplete, {\n  name: PREFIX,\n  overridesResolver: function (props, styles) {\n    return styles.root;\n  }\n})(function (_a) {\n  var _b;\n\n  var theme = _a.theme;\n  return _b = {}, _b[\"& .\".concat(AutocompleteInputClasses.textField)] = {\n    minWidth: theme.spacing(20)\n  }, _b;\n});\n/**\n * Returns the selected choice (or choices if multiple) by matching the input value with the choices.\n */\n\nvar useSelectedChoice = function (value, _a) {\n  var choices = _a.choices,\n      multiple = _a.multiple,\n      optionValue = _a.optionValue;\n  var selectedChoiceRef = useRef(getSelectedItems(choices, value, optionValue, multiple));\n\n  var _b = useState(function () {\n    return getSelectedItems(choices, value, optionValue, multiple);\n  }),\n      selectedChoice = _b[0],\n      setSelectedChoice = _b[1]; // As the selected choices are objects, we want to ensure we pass the same\n  // reference to the Autocomplete as it would reset its filter value otherwise.\n\n\n  useEffect(function () {\n    var newSelectedItems = getSelectedItems(choices, value, optionValue, multiple);\n\n    if (!areSelectedItemsEqual(selectedChoiceRef.current, newSelectedItems, optionValue, multiple)) {\n      selectedChoiceRef.current = newSelectedItems;\n      setSelectedChoice(newSelectedItems);\n    }\n  }, [choices, value, multiple, optionValue]);\n  return selectedChoice || null;\n};\n\nvar getSelectedItems = function (choices, value, optionValue, multiple) {\n  if (choices === void 0) {\n    choices = [];\n  }\n\n  if (optionValue === void 0) {\n    optionValue = 'id';\n  }\n\n  if (multiple) {\n    return (Array.isArray(value !== null && value !== void 0 ? value : []) ? value : [value]).map(function (item) {\n      return choices.find(function (choice) {\n        return String(item) === String(get(choice, optionValue));\n      });\n    }).filter(function (item) {\n      return !!item;\n    });\n  }\n\n  return choices.find(function (choice) {\n    return String(get(choice, optionValue)) === String(value);\n  }) || '';\n};\n\nvar areSelectedItemsEqual = function (selectedChoice, newSelectedChoice, optionValue, multiple) {\n  var _a, _b;\n\n  if (optionValue === void 0) {\n    optionValue = 'id';\n  }\n\n  if (multiple) {\n    var selectedChoiceArray = (_a = selectedChoice) !== null && _a !== void 0 ? _a : [];\n    var newSelectedChoiceArray_1 = (_b = newSelectedChoice) !== null && _b !== void 0 ? _b : [];\n\n    if (selectedChoiceArray.length !== newSelectedChoiceArray_1.length) {\n      return false;\n    }\n\n    var equalityArray = selectedChoiceArray.map(function (choice) {\n      return newSelectedChoiceArray_1.some(function (newChoice) {\n        return get(newChoice, optionValue) === get(choice, optionValue);\n      });\n    });\n    return !equalityArray.some(function (item) {\n      return item === false;\n    });\n  }\n\n  return get(selectedChoice, optionValue) === get(newSelectedChoice, optionValue);\n};\n\nvar DefaultFilterToQuery = function (searchText) {\n  return {\n    q: searchText\n  };\n};","map":{"version":3,"mappings":"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","names":["React","isValidElement","useCallback","useEffect","useMemo","useRef","useState","debounce","get","isEqual","clsx","Autocomplete","Chip","TextField","createFilterOptions","styled","FieldTitle","useChoicesContext","useInput","useSuggestions","useTimeout","useTranslate","warning","useGetRecordRepresentation","useSupportCreateSuggestion","InputHelperText","sanitizeInputRestProps","defaultFilterOptions","AutocompleteInput","props","choicesProp","className","_a","clearOnBlur","_b","clearText","_c","closeText","create","createLabel","createItemLabel","createValue","_d","debounceDelay","defaultValue","emptyText","_e","emptyValue","fieldOverride","format","helperText","idOverride","inputText","isFetchingProp","isLoadingProp","isRequiredOverride","label","limitChoicesToValue","matchSuggestion","margin","fieldStateOverride","_f","filterToQuery","DefaultFilterToQuery","formStateOverride","_g","multiple","noOptionsText","onBlur","onChange","onCreate","_h","openText","optionText","optionValue","parse","resourceProp","shouldRenderSuggestions","setFilter","size","sourceProp","_j","suggestionLimit","Infinity","TextFieldProps","translateChoice","validate","variant","rest","choices","isFetching","isLoading","resource","source","allChoices","fetchError","setFilters","isFromReference","translate","id","field","fieldState","formState","isRequired","_m","error","invalid","isTouched","isSubmitted","finalChoices","undefined","_","concat","selectedChoice","useSelectedChoice","value","Error","getRecordRepresentation","selectedItem","getChoiceText","getChoiceValue","getSuggestions","filterValue","setFilterValue","handleChange","newValue","Array","isArray","map","__spreadArray","debouncedSetFilter","filter","currentValue","current","getCreateItem","handleChangeWithCreateSupport","createElement","createId","getOptionLabel","option","isListItem","finalOnBlur","optionLabel","handleInputChange","event","newInputValue","reason","type","doesQueryMatchSelection","selectedItemTexts","item","includes","doesQueryMatchSuggestion","hasOption","some","choice","filterOptions","options","params","filteredOptions","inputValue","handleAutocompleteChange","oneSecondHasPassed","suggestions","slice","isOptionEqualToValue","String","StyledAutocomplete","__assign","blurOnSelect","openOnFocus","filterSelectedOptions","renderInput","name","touched","message","AutocompleteInputClasses","textField","renderTags","getTagProps","index","sx","zIndex","selectOnFocus","freeSolo","handleHomeEndKeys","loading","length","onInputChange","renderOption","record","key","PREFIX","overridesResolver","styles","root","theme","minWidth","spacing","selectedChoiceRef","getSelectedItems","setSelectedChoice","newSelectedItems","areSelectedItemsEqual","find","newSelectedChoice","selectedChoiceArray","newSelectedChoiceArray_1","equalityArray","newChoice","q","searchText"],"sources":["/var/www/a1boots/node_modules/ra-ui-materialui/src/input/AutocompleteInput.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n    isValidElement,\n    useCallback,\n    useEffect,\n    useMemo,\n    useRef,\n    useState,\n    ReactNode,\n} from 'react';\nimport debounce from 'lodash/debounce';\nimport get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport clsx from 'clsx';\nimport {\n    Autocomplete,\n    AutocompleteProps,\n    Chip,\n    TextField,\n    TextFieldProps,\n    createFilterOptions,\n} from '@mui/material';\nimport { styled } from '@mui/material/styles';\nimport {\n    ChoicesProps,\n    FieldTitle,\n    RaRecord,\n    useChoicesContext,\n    useInput,\n    useSuggestions,\n    UseSuggestionsOptions,\n    useTimeout,\n    useTranslate,\n    warning,\n    useGetRecordRepresentation,\n} from 'ra-core';\nimport {\n    SupportCreateSuggestionOptions,\n    useSupportCreateSuggestion,\n} from './useSupportCreateSuggestion';\nimport { CommonInputProps } from './CommonInputProps';\nimport { InputHelperText } from './InputHelperText';\nimport { sanitizeInputRestProps } from './sanitizeInputRestProps';\n\nconst defaultFilterOptions = createFilterOptions();\n\n/**\n * An Input component for an autocomplete field, using an array of objects for the options\n *\n * Pass possible options as an array of objects in the 'choices' attribute.\n *\n * By default, the options are built from:\n *  - the 'id' property as the option value,\n *  - the 'name' property as the option text\n * @example\n * const choices = [\n *    { id: 'M', name: 'Male' },\n *    { id: 'F', name: 'Female' },\n * ];\n * <AutocompleteInput source=\"gender\" choices={choices} />\n *\n * You can also customize the properties to use for the option name and value,\n * thanks to the 'optionText' and 'optionValue' attributes.\n * @example\n * const choices = [\n *    { _id: 123, full_name: 'Leo Tolstoi', sex: 'M' },\n *    { _id: 456, full_name: 'Jane Austen', sex: 'F' },\n * ];\n * <AutocompleteInput source=\"author_id\" choices={choices} optionText=\"full_name\" optionValue=\"_id\" />\n *\n * `optionText` also accepts a function, so you can shape the option text at will:\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;\n * <AutocompleteInput source=\"author_id\" choices={choices} optionText={optionRenderer} />\n *\n * `optionText` also accepts a React Element, that can access\n * the related choice through the `useRecordContext` hook. You can use Field components there.\n * Note that you must also specify the `matchSuggestion` and `inputText` props\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const matchSuggestion = (filterValue, choice) => choice.first_name.match(filterValue) || choice.last_name.match(filterValue)\n * const inputText = (record) => `${record.fullName} (${record.language})`;\n *\n * const FullNameField = () => {\n *     const record = useRecordContext();\n *     return <span>{record.first_name} {record.last_name}</span>;\n * }\n * <AutocompleteInput source=\"author\" choices={choices} optionText={<FullNameField />} matchSuggestion={matchSuggestion} inputText={inputText} />\n *\n * The choices are translated by default, so you can use translation identifiers as choices:\n * @example\n * const choices = [\n *    { id: 'M', name: 'myroot.gender.male' },\n *    { id: 'F', name: 'myroot.gender.female' },\n * ];\n *\n * However, in some cases (e.g. inside a `<ReferenceInput>`), you may not want\n * the choice to be translated. In that case, set the `translateChoice` prop to false.\n * @example\n * <AutocompleteInput source=\"gender\" choices={choices} translateChoice={false}/>\n *\n * The object passed as `options` props is passed to the Material UI <TextField> component\n *\n * @example\n * <AutocompleteInput source=\"author_id\" options={{ color: 'secondary', InputLabelProps: { shrink: true } }} />\n */\nexport const AutocompleteInput = <\n    OptionType extends RaRecord = RaRecord,\n    Multiple extends boolean | undefined = false,\n    DisableClearable extends boolean | undefined = false,\n    SupportCreate extends boolean | undefined = false\n>(\n    props: AutocompleteInputProps<\n        OptionType,\n        Multiple,\n        DisableClearable,\n        SupportCreate\n    >\n) => {\n    const {\n        choices: choicesProp,\n        className,\n        clearOnBlur = true,\n        clearText = 'ra.action.clear_input_value',\n        closeText = 'ra.action.close',\n        create,\n        createLabel,\n        createItemLabel,\n        createValue,\n        debounce: debounceDelay = 250,\n        defaultValue,\n        emptyText,\n        emptyValue = '',\n        field: fieldOverride,\n        format,\n        helperText,\n        id: idOverride,\n        inputText,\n        isFetching: isFetchingProp,\n        isLoading: isLoadingProp,\n        isRequired: isRequiredOverride,\n        label,\n        limitChoicesToValue,\n        matchSuggestion,\n        margin,\n        fieldState: fieldStateOverride,\n        filterToQuery = DefaultFilterToQuery,\n        formState: formStateOverride,\n        multiple = false,\n        noOptionsText,\n        onBlur,\n        onChange,\n        onCreate,\n        openText = 'ra.action.open',\n        optionText,\n        optionValue,\n        parse,\n        resource: resourceProp,\n        shouldRenderSuggestions,\n        setFilter,\n        size,\n        source: sourceProp,\n        suggestionLimit = Infinity,\n        TextFieldProps,\n        translateChoice,\n        validate,\n        variant,\n        ...rest\n    } = props;\n\n    const {\n        allChoices,\n        isLoading,\n        error: fetchError,\n        resource,\n        source,\n        setFilters,\n        isFromReference,\n    } = useChoicesContext({\n        choices: choicesProp,\n        isFetching: isFetchingProp,\n        isLoading: isLoadingProp,\n        resource: resourceProp,\n        source: sourceProp,\n    });\n\n    const translate = useTranslate();\n\n    const {\n        id,\n        field,\n        isRequired,\n        fieldState: { error, invalid, isTouched },\n        formState: { isSubmitted },\n    } = useInput({\n        defaultValue,\n        id: idOverride,\n        field: fieldOverride,\n        fieldState: fieldStateOverride,\n        formState: formStateOverride,\n        isRequired: isRequiredOverride,\n        onBlur,\n        onChange,\n        parse,\n        format,\n        resource,\n        source,\n        validate,\n        ...rest,\n    });\n\n    const finalChoices = useMemo(\n        () =>\n            // eslint-disable-next-line eqeqeq\n            emptyText == undefined || isRequired || multiple\n                ? allChoices\n                : [\n                      {\n                          [optionValue || 'id']: emptyValue,\n                          [typeof optionText === 'string'\n                              ? optionText\n                              : 'name']: translate(emptyText, {\n                              _: emptyText,\n                          }),\n                      },\n                  ].concat(allChoices),\n        [\n            allChoices,\n            emptyValue,\n            emptyText,\n            isRequired,\n            multiple,\n            optionText,\n            optionValue,\n            translate,\n        ]\n    );\n\n    const selectedChoice = useSelectedChoice<\n        OptionType,\n        Multiple,\n        DisableClearable,\n        SupportCreate\n    >(field.value, {\n        choices: finalChoices,\n        // @ts-ignore\n        multiple,\n        optionValue,\n    });\n\n    useEffect(() => {\n        // eslint-disable-next-line eqeqeq\n        if (emptyValue == null) {\n            throw new Error(\n                `emptyValue being set to null or undefined is not supported. Use parse to turn the empty string into null.`\n            );\n        }\n    }, [emptyValue]);\n\n    useEffect(() => {\n        // eslint-disable-next-line eqeqeq\n        if (isValidElement(optionText) && emptyText != undefined) {\n            throw new Error(\n                `optionText of type React element is not supported when setting emptyText`\n            );\n        }\n        // eslint-disable-next-line eqeqeq\n        if (isValidElement(optionText) && inputText == undefined) {\n            throw new Error(`\nIf you provided a React element for the optionText prop, you must also provide the inputText prop (used for the text input)`);\n        }\n        // eslint-disable-next-line eqeqeq\n        if (isValidElement(optionText) && matchSuggestion == undefined) {\n            throw new Error(`\nIf you provided a React element for the optionText prop, you must also provide the matchSuggestion prop (used to match the user input with a choice)`);\n        }\n    }, [optionText, inputText, matchSuggestion, emptyText]);\n\n    useEffect(() => {\n        warning(\n            /* eslint-disable eqeqeq */\n            shouldRenderSuggestions != undefined && noOptionsText == undefined,\n            `When providing a shouldRenderSuggestions function, we recommend you also provide the noOptionsText prop and set it to a text explaining users why no options are displayed. It supports translation keys.`\n        );\n        /* eslint-enable eqeqeq */\n    }, [shouldRenderSuggestions, noOptionsText]);\n\n    const getRecordRepresentation = useGetRecordRepresentation(resource);\n\n    const { getChoiceText, getChoiceValue, getSuggestions } = useSuggestions({\n        choices: finalChoices,\n        limitChoicesToValue,\n        matchSuggestion,\n        optionText:\n            optionText ??\n            (isFromReference ? getRecordRepresentation : undefined),\n        optionValue,\n        selectedItem: selectedChoice,\n        suggestionLimit,\n        translateChoice,\n    });\n\n    const [filterValue, setFilterValue] = useState('');\n\n    const handleChange = (newValue: any) => {\n        if (multiple) {\n            if (Array.isArray(newValue)) {\n                field.onChange(newValue.map(getChoiceValue));\n            } else {\n                field.onChange([\n                    ...(field.value ?? []),\n                    getChoiceValue(newValue),\n                ]);\n            }\n        } else {\n            field.onChange(getChoiceValue(newValue) ?? emptyValue);\n        }\n    };\n\n    // eslint-disable-next-line\n    const debouncedSetFilter = useCallback(\n        debounce(filter => {\n            if (setFilter) {\n                return setFilter(filter);\n            }\n\n            if (choicesProp) {\n                return;\n            }\n\n            setFilters(filterToQuery(filter), undefined, true);\n        }, debounceDelay),\n        [debounceDelay, setFilters, setFilter]\n    );\n\n    // We must reset the filter every time the value changes to ensure we\n    // display at least some choices even if the input has a value.\n    // Otherwise, it would only display the currently selected one and the user\n    // would have to first clear the input before seeing any other choices\n    const currentValue = useRef(field.value);\n    useEffect(() => {\n        if (!isEqual(currentValue.current, field.value)) {\n            currentValue.current = field.value;\n            debouncedSetFilter('');\n        }\n    }, [field.value]); // eslint-disable-line\n\n    const {\n        getCreateItem,\n        handleChange: handleChangeWithCreateSupport,\n        createElement,\n        createId,\n    } = useSupportCreateSuggestion({\n        create,\n        createLabel,\n        createItemLabel,\n        createValue,\n        handleChange,\n        filter: filterValue,\n        onCreate,\n        optionText,\n    });\n\n    const getOptionLabel = useCallback(\n        (option: any, isListItem: boolean = false) => {\n            // eslint-disable-next-line eqeqeq\n            if (option == undefined) {\n                return '';\n            }\n\n            // Value selected with enter, right from the input\n            if (typeof option === 'string') {\n                return option;\n            }\n\n            if (option?.id === createId) {\n                return get(\n                    option,\n                    typeof optionText === 'string' ? optionText : 'name'\n                );\n            }\n\n            if (!isListItem && option[optionValue || 'id'] === emptyValue) {\n                return get(\n                    option,\n                    typeof optionText === 'string' ? optionText : 'name'\n                );\n            }\n\n            if (!isListItem && inputText !== undefined) {\n                return inputText(option);\n            }\n\n            return getChoiceText(option);\n        },\n        [\n            getChoiceText,\n            inputText,\n            createId,\n            optionText,\n            optionValue,\n            emptyValue,\n        ]\n    );\n\n    const finalOnBlur = useCallback((): void => {\n        if (clearOnBlur && !multiple) {\n            const optionLabel = getOptionLabel(selectedChoice);\n            if (!isEqual(optionLabel, filterValue)) {\n                setFilterValue(optionLabel);\n                debouncedSetFilter('');\n            }\n        }\n        field.onBlur();\n    }, [\n        clearOnBlur,\n        field,\n        getOptionLabel,\n        selectedChoice,\n        filterValue,\n        debouncedSetFilter,\n        multiple,\n    ]);\n\n    useEffect(() => {\n        if (!multiple) {\n            const optionLabel = getOptionLabel(selectedChoice);\n            if (typeof optionLabel === 'string') {\n                setFilterValue(optionLabel);\n            } else {\n                throw new Error(\n                    'When optionText returns a React element, you must also provide the inputText prop'\n                );\n            }\n        }\n    }, [getOptionLabel, multiple, selectedChoice]);\n\n    const handleInputChange = (\n        event: any,\n        newInputValue: string,\n        reason: string\n    ) => {\n        if (\n            event?.type === 'change' ||\n            !doesQueryMatchSelection(newInputValue)\n        ) {\n            setFilterValue(newInputValue);\n            debouncedSetFilter(newInputValue);\n        }\n    };\n\n    const doesQueryMatchSelection = useCallback(\n        (filter: string) => {\n            let selectedItemTexts;\n\n            if (multiple) {\n                selectedItemTexts = selectedChoice.map(item =>\n                    getOptionLabel(item)\n                );\n            } else {\n                selectedItemTexts = [getOptionLabel(selectedChoice)];\n            }\n\n            return selectedItemTexts.includes(filter);\n        },\n        [getOptionLabel, multiple, selectedChoice]\n    );\n    const doesQueryMatchSuggestion = useCallback(\n        filter => {\n            const hasOption = !!finalChoices\n                ? finalChoices.some(choice => getOptionLabel(choice) === filter)\n                : false;\n\n            return doesQueryMatchSelection(filter) || hasOption;\n        },\n        [finalChoices, getOptionLabel, doesQueryMatchSelection]\n    );\n\n    const filterOptions = (options, params) => {\n        let filteredOptions =\n            isFromReference || // When used inside a reference, AutocompleteInput shouldn't do the filtering as it's done by the reference input\n            matchSuggestion || // When using element as optionText (and matchSuggestion), options are filtered by getSuggestions, so they shouldn't be filtered here\n            limitChoicesToValue // When limiting choices to values (why? it's legacy!), options are also filtered by getSuggestions, so they shouldn't be filtered here\n                ? options\n                : defaultFilterOptions(options, params); // Otherwise, we let Material UI's Autocomplete do the filtering\n\n        // add create option if necessary\n        const { inputValue } = params;\n        if (\n            (onCreate || create) &&\n            inputValue !== '' &&\n            !doesQueryMatchSuggestion(filterValue)\n        ) {\n            filteredOptions = filteredOptions.concat(getCreateItem(inputValue));\n        }\n\n        return filteredOptions;\n    };\n\n    const handleAutocompleteChange = (\n        event: any,\n        newValue: any,\n        reason: string\n    ) => {\n        handleChangeWithCreateSupport(newValue != null ? newValue : emptyValue);\n    };\n\n    const oneSecondHasPassed = useTimeout(1000, filterValue);\n\n    const suggestions = useMemo(() => {\n        if (matchSuggestion || limitChoicesToValue) {\n            return getSuggestions(filterValue);\n        }\n        return finalChoices?.slice(0, suggestionLimit) || [];\n    }, [\n        finalChoices,\n        filterValue,\n        getSuggestions,\n        limitChoicesToValue,\n        matchSuggestion,\n        suggestionLimit,\n    ]);\n\n    const isOptionEqualToValue = (option, value) => {\n        return String(getChoiceValue(option)) === String(getChoiceValue(value));\n    };\n\n    return (\n        <>\n            <StyledAutocomplete\n                blurOnSelect\n                className={clsx('ra-input', `ra-input-${source}`, className)}\n                clearText={translate(clearText, { _: clearText })}\n                closeText={translate(closeText, { _: closeText })}\n                openOnFocus\n                openText={translate(openText, { _: openText })}\n                id={id}\n                isOptionEqualToValue={isOptionEqualToValue}\n                filterSelectedOptions\n                renderInput={params => (\n                    <TextField\n                        name={field.name}\n                        label={\n                            <FieldTitle\n                                label={label}\n                                source={source}\n                                resource={resourceProp}\n                                isRequired={isRequired}\n                            />\n                        }\n                        error={\n                            !!fetchError ||\n                            ((isTouched || isSubmitted) && invalid)\n                        }\n                        helperText={\n                            <InputHelperText\n                                touched={isTouched || isSubmitted || fetchError}\n                                error={error?.message || fetchError?.message}\n                                helperText={helperText}\n                            />\n                        }\n                        margin={margin}\n                        variant={variant}\n                        className={AutocompleteInputClasses.textField}\n                        {...TextFieldProps}\n                        {...params}\n                        size={size}\n                    />\n                )}\n                multiple={multiple}\n                renderTags={(value, getTagProps) =>\n                    value.map((option, index) => (\n                        <Chip\n                            label={\n                                isValidElement(optionText)\n                                    ? inputText(option)\n                                    : getChoiceText(option)\n                            }\n                            sx={{\n                                '.MuiSvgIcon-root': {\n                                    // FIXME: Workaround to allow choices deletion\n                                    // Maybe related to storybook and mui using different versions of emotion\n                                    zIndex: 100,\n                                },\n                            }}\n                            size=\"small\"\n                            {...getTagProps({ index })}\n                        />\n                    ))\n                }\n                noOptionsText={\n                    typeof noOptionsText === 'string'\n                        ? translate(noOptionsText, { _: noOptionsText })\n                        : noOptionsText\n                }\n                selectOnFocus\n                clearOnBlur={clearOnBlur}\n                {...sanitizeInputRestProps(rest)}\n                freeSolo={!!create || !!onCreate}\n                handleHomeEndKeys={!!create || !!onCreate}\n                filterOptions={filterOptions}\n                options={\n                    shouldRenderSuggestions == undefined || // eslint-disable-line eqeqeq\n                    shouldRenderSuggestions(filterValue)\n                        ? suggestions\n                        : []\n                }\n                getOptionLabel={getOptionLabel}\n                inputValue={filterValue}\n                loading={\n                    isLoading &&\n                    (!finalChoices || finalChoices.length === 0) &&\n                    oneSecondHasPassed\n                }\n                value={selectedChoice}\n                onChange={handleAutocompleteChange}\n                onBlur={finalOnBlur}\n                onInputChange={handleInputChange}\n                renderOption={(props, record: RaRecord) => {\n                    (props as {\n                        key: string;\n                    }).key = getChoiceValue(record);\n\n                    const optionLabel = getOptionLabel(record, true);\n\n                    return (\n                        <li {...props}>\n                            {optionLabel === '' ? ' ' : optionLabel}\n                        </li>\n                    );\n                }}\n            />\n            {createElement}\n        </>\n    );\n};\n\nconst PREFIX = 'RaAutocompleteInput';\n\nexport const AutocompleteInputClasses = {\n    textField: `${PREFIX}-textField`,\n};\n\nconst StyledAutocomplete = styled(Autocomplete, {\n    name: PREFIX,\n    overridesResolver: (props, styles) => styles.root,\n})(({ theme }) => ({\n    [`& .${AutocompleteInputClasses.textField}`]: {\n        minWidth: theme.spacing(20),\n    },\n}));\n\n// @ts-ignore\nexport interface AutocompleteInputProps<\n    OptionType extends any = RaRecord,\n    Multiple extends boolean | undefined = false,\n    DisableClearable extends boolean | undefined = false,\n    SupportCreate extends boolean | undefined = false\n> extends Omit<CommonInputProps, 'source'>,\n        ChoicesProps,\n        UseSuggestionsOptions,\n        Omit<SupportCreateSuggestionOptions, 'handleChange' | 'optionText'>,\n        Omit<\n            AutocompleteProps<\n                OptionType,\n                Multiple,\n                DisableClearable,\n                SupportCreate\n            >,\n            'onChange' | 'options' | 'renderInput'\n        > {\n    children?: ReactNode;\n    debounce?: number;\n    emptyText?: string;\n    emptyValue?: any;\n    filterToQuery?: (searchText: string) => any;\n    inputText?: (option: any) => string;\n    setFilter?: (value: string) => void;\n    shouldRenderSuggestions?: any;\n    // Source is optional as AutocompleteInput can be used inside a ReferenceInput that already defines the source\n    source?: string;\n    TextFieldProps?: TextFieldProps;\n}\n\n/**\n * Returns the selected choice (or choices if multiple) by matching the input value with the choices.\n */\nconst useSelectedChoice = <\n    OptionType extends any = RaRecord,\n    Multiple extends boolean | undefined = false,\n    DisableClearable extends boolean | undefined = false,\n    SupportCreate extends boolean | undefined = false\n>(\n    value: any,\n    {\n        choices,\n        multiple,\n        optionValue,\n    }: AutocompleteInputProps<\n        OptionType,\n        Multiple,\n        DisableClearable,\n        SupportCreate\n    >\n) => {\n    const selectedChoiceRef = useRef(\n        getSelectedItems(choices, value, optionValue, multiple)\n    );\n    const [selectedChoice, setSelectedChoice] = useState<RaRecord | RaRecord[]>(\n        () => getSelectedItems(choices, value, optionValue, multiple)\n    );\n\n    // As the selected choices are objects, we want to ensure we pass the same\n    // reference to the Autocomplete as it would reset its filter value otherwise.\n    useEffect(() => {\n        const newSelectedItems = getSelectedItems(\n            choices,\n            value,\n            optionValue,\n            multiple\n        );\n\n        if (\n            !areSelectedItemsEqual(\n                selectedChoiceRef.current,\n                newSelectedItems,\n                optionValue,\n                multiple\n            )\n        ) {\n            selectedChoiceRef.current = newSelectedItems;\n            setSelectedChoice(newSelectedItems);\n        }\n    }, [choices, value, multiple, optionValue]);\n    return selectedChoice || null;\n};\n\nconst getSelectedItems = (\n    choices = [],\n    value,\n    optionValue = 'id',\n    multiple\n) => {\n    if (multiple) {\n        return (Array.isArray(value ?? []) ? value : [value])\n            .map(item =>\n                choices.find(\n                    choice => String(item) === String(get(choice, optionValue))\n                )\n            )\n            .filter(item => !!item);\n    }\n    return (\n        choices.find(\n            choice => String(get(choice, optionValue)) === String(value)\n        ) || ''\n    );\n};\n\nconst areSelectedItemsEqual = (\n    selectedChoice: RaRecord | RaRecord[],\n    newSelectedChoice: RaRecord | RaRecord[],\n    optionValue = 'id',\n    multiple: boolean\n) => {\n    if (multiple) {\n        const selectedChoiceArray = (selectedChoice as RaRecord[]) ?? [];\n        const newSelectedChoiceArray = (newSelectedChoice as RaRecord[]) ?? [];\n        if (selectedChoiceArray.length !== newSelectedChoiceArray.length) {\n            return false;\n        }\n        const equalityArray = selectedChoiceArray.map(choice =>\n            newSelectedChoiceArray.some(\n                newChoice =>\n                    get(newChoice, optionValue) === get(choice, optionValue)\n            )\n        );\n        return !equalityArray.some(item => item === false);\n    }\n    return (\n        get(selectedChoice, optionValue) === get(newSelectedChoice, optionValue)\n    );\n};\n\nconst DefaultFilterToQuery = searchText => ({ q: searchText });\n"]},"metadata":{},"sourceType":"module"}